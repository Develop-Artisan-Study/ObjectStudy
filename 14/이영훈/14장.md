# 일관성 있는 협력
> 재사용을 위해서는 객체들의 협력 방식을 일관성 있게 만들어야 한다.  
> 일관성은 설계에 드는 비용을 감소시킨다.

## 핸드폰 과금 시스템 변경하기
결론은 유사한 기능을 서로 다른 방식으로 구현해서는 안 된다는 것이다.  
   
이 장의 코드 설계가 훌륭하다고 말하기 어려운 이유는 기본 정책을 구현하는 기존 클래스들과 일관성이 없기 때문이다.  
**기존의 설계가 어떤 가이드도 제공하지 않기 때문에** 새로운 기본 정책을 구현해야 하는 상황에서 다른 개발자는 또 다른 방식으로 기본 정책을 구현할 가능성이 높다.

## 설계에 일관성 부여하기
협력을 일관성 있게 만들기 위한 기본 지침
- 변하는 개념을 변하지 않는 개념으로부터 분리하라.
- 변하는 개념을 캡슐화하라.
   
클래스를 분리하기 위한 가장 중요한 기준은 변경의 이유와 주기다.  
클래스는 명확히 단 하나의 이유에 의해서만 변경돼야 하고 클래스 안의 모든 코드는 함께 변경돼야 한다.  
-> 단일 책임 원칙을 따르도록 클래스를 분리해야 한다.
   
핵심은 훌륭한 추상화를 찾아 추상화에 의존하도록 만드는 것이다.  
추상화에 대한 의존은 결합도를 낮추고 결과적으로 대체 가능한 역할로 구성된 협력을 설계할 수 있게 해준다.  
따라서 선택하는 추상화의 품질이 캡슐화의 품질을 결정한다.  

### 캡슐화 다시 살펴보기
> 캡슐화란 변하는 어떤 것이든 감추는 것이다.
캡슐화란 단순히 데이터를 감추는 것이 안이다. 소프트웨어 안에서 변할 수 있는 모든 '개념'을 감추는 것이다.  
   
캡슐화의 가장 대표적인 예는 객체의 퍼블릭 인터페이스와 구현을 분리하는 것이다.  
자주 변경되는 내부 구현을 안정적인 퍼블릭 인터페이스 뒤로 숨겨야 한다.  
   
- 다양한 종류의 캡슐화
  - 데이터 캡슐화 : 내부에 관리하는 데이터를 캡슐화한다.
  - 메서드 캡슐화 : 클래스의 내부 행동을 캡슐화한다.
  - 객체 캡슐화 : 객체와 객체 사이의 관계를 캡슐화한다. 합성을 의미한다.
  - 서브타입 캡슐화 : 서브타입의 종류를 캡슐화한다. 다형성의 기반이 된다.

코드 수정으로 인한 파급효과를 제어할 수 있는 모든 기법이 캡슐화의 일종이다.  
   
협력을 일관성 있게 만들기 위해 가장 일반적으로 사용하는 방법은 서브타입 캡슐화와 객체 캡슐화를 조합하는 것이다.  
서브타입 캡슐화는 인터페이스 상속을 사용하고, 객체 캡슐화는 합성을 사용한다.  
   
- 서브타입 캡슐화와 객체 캡슐화를 적용하는 방법
  - 변하는 부분을 분리해서 타입 계층을 만든다
  - 변하지 않는 부분의 일부로 타입 계층을 합성한다

위 내용은 조건 로직을 객체 이동으로 대체함으로써 변경을 캡슐화할 수 있는 다양한 방법 중 가장 대표적인 방법일 뿐이다  
더 다양한 방법을 위해서는 디자인 패턴을 살펴보자  

## 일관성 있는 기본 정책 구현하기
### 변경 분리하기
일관성 있는 협력을 만들기 위한 첫 번째 단계는 변하는 개념과 변하지 않는 개념을 분리하는 것이다.

### 변경 캡슐화하기
변경을 캡슐화하는 가장 좋은 방법은 변하지 않는 부분으로부터 변하는 부분을 분리하는 것이다.  
변하는 부분의 공통점을 추상화 하는 것도 잊어서는 안 된다.  
이제 변하지 않는 부분이 오직 이 추상화에만 의존하도록 관계를 제한하면 변경을 캡슐화할 수 있게 된다.  

### 협력 패턴 설계하기
변하는 부분과 변하지 않는 부분을 분리하고, 변하는 부분을 적절히 추상화하고 나면 변하는 부분을 생략한 채 변하지 않는 부분만을 이용해 객체 사이의 협력을 이야기할 수 있다.  
추상화만으로 구성한 협력은 추상화를 구체적인 사례로 대체함으로써 다양한 상황으로 확장할 수 있게 된다. 다시 말해서 재사용 가능한 협력 패턴이 선명하게 드러나는 것이다.  
   
설계가 올바른 방향으로 나아가고 있는지 확인할 수 있는 유일한 방법은 협력을 직접 구현해 보는 것뿐이다.  

### 추상화 수준에서 협력 패턴 구현하기
변하지 않는 추상화에 해당하는 클래스와 인터페이스를 모두 구현한 후, 이를 조합하면 전체적인 협력 구조가 완성된다.  
변하지 않는 요소와 추상적인 요소만으로도 필요한 전체적인 협력 구조를 설명할 수 있다는 것이다.  
변하는 것은 추상화 뒤에 캡슐화되어 숨겨져 있기 때문에 전체적인 협력의 구조에 영향을 미치지 않는다.  

### 구체적인 협력 구현하기
변하는 부분을 변하지 않는 부분으로부터 분리하면 변하지 않는 부분을 재사용할 수 있다. 그리고 새로운 기능을 추가하기 위해 오직 변하는 부분만 구현하면 된다.  
-> 코드의 재사용성이 향상되고 테스트해야 하는 코드의 양이 감소한다.  
   
일관성 있는 협력은 개발자에게 확장 포인트를 강제하기 때문에 **정해진 구조를 우회하기 어렵게 만든다.**  
   
- 개념적 무결성  
  유사한 기능에 대해 유사한 협력 패턴을 적용하는 것, 일관성과 동일한 뜻으로 간주해도 무방하다

### 협력 패턴에 맞추기
> 비록 설계를 약간 비트는 것이 조금은 이상한 구조를 낳더라도 전체적으로 일관성을 유지할 수 있는 설계를 선택하는 것이 현명하다.
   
> 협력은 고정된 것이 아니다. 만약 현재의 협력 패턴이 변경의 무게를 지탱하기 어렵다면 변경을 수용할 수 있는 협력 패턴을 향해 과감하게 리팩터링하라.  
> 중요한 것은 현재의 설계에 맹목적으로 일관성을 맞추는 것이 아니라 달라지는 변경의 방향에 맞춰 지속적으로 코드를 개선하려는 의지다.

### 패턴을 찾아라
- 협력 패턴과 관련해서 언급할 가치가 있는 두 가지 개념
  - 패턴
  - 프레임워크
   
다음 장에서 계속...
