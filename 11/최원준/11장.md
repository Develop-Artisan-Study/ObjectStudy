# 합성과 유연한 설계

- 관계
  - 상속: is-a관계
  - 합성: has-a관계
- 상속
  - 부모 클래스의 이름을 사용하는 것 만으로도 부모 클래스의 코드를 사용 가능
  - 부모 클래스의 내부 구현에 대해 상세하게 알아야하며 이로 인해 결합도가 높아진다.
  - 정적인 관계이다.
- 합성
  - 구현에 의존하지 않는다.
  - 내부의 객체 구현이 아닌 퍼블릭 인터페이스에 의존한다.
  - 동적인 관계이다.
- 상속과 합성은 재사용의 대상이 다르다.

## 상속을 합성으로 변경하기

- 상속에서 생기는 문제들
  - 불필요한 인터페이스 상속 문제
    - 자식 클래스에게 부적합한 부모 클래스의 오퍼레이션이 상속됨
    - 이로 인해 자식 클래스 인스턴스의 상태가 불안정해짐
    - 인터페이스 분리 원칙을 위반
  - 메서드 오버라이딩의 오작용 문제
    - 자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 때 부모 클래스의 영향을 받는 문제
  - 부모 클래스와 자식 클래스의 동시 수정 문제
    - 부모 클래스와 자식 클래스의 개념적인 결합으로 인해 함께 변경해야 하는 문제

### 불필요한 인터페이스 상속 문제

java.util.Properties와 java.util.Stack

- Properties가 Stack을 상속받고 있어서 Stack의 불필요한 메소드들을 Properties에서 사용할 수 있음
- 하지만 합성으로 바꾸면 Properties에서 정의한 방법을 통해서만 Stack에 접근이 가능

### 메서드 오버라이딩의 오작용 문제

- 상속이 아니라 합성을 통해 인터페이스를 외부에 그대로 제공

### 부모 클래스와 자식 클래스의 동시 수정 문제

- playlist와의 결합은 여전하지만 합성된 Playlist의 변화로 인한 파급효과를 내부에 끼치지 않음

## 상속으로 인한 조합의 폭발적인 증가

- 상속으로 인해 결합도가 높아지면 코드를 수정하는 데 필요한 작업의 양이 과도하게 늘어나는 경향이 있다.
- 작은 기능들을 조합해서 더 큰 기능을 수행하는 객체를 만들어야 하는 경우 두가지 문제가 발생한다
  - 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.
  - 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.
- 상속이 아닌 합성을 통해 이 문제를 해결 할 수 있다.

### 기본 정책과 부가 정책 조합하기

- 도메인 분석
  - 기본 정책
    - 일반 요금제
    - 심야 할인 요금제
  - 부가 정책
    - 세금 정책
    - 기본 요금 할인 정책
- 부가 정책의 특성
  - 기본 정책이 계산 결과에 적용된다
  - 선택적으로 적용할 수 있다
  - 조합 가능하다
  - 부가 정책은 임의의 순서로 적용 가능하다

### 상속을 이용해서 기본 정책 구현하기

### 기본 정책에 세금 정책 조합하기

### 기본 정책에 기본 요금 할인 정책 조합하기

### 중복 코드의 덫에 걸리다

## 합성 관계로 변경하기

- 상속 관계는 컴파일타임에 결정되고 고정되기 때문에 코드를 실행하는 도중에는 변경할 수 없다.
- 합성 관계는 컴파일 타임 관계를 런타임 관계로 변경함으로써 이 문제를 해결한다.
- 대부분의 경우 단순한 설계가 정답이지만 변경의 비용에 따라 유연성을 선택해야 할 때도 있다.
- 변경하게 편리한 설계를 만들기 위해 복잡성을 더하고 나면 단순해지는 경우도 종종 목격된다.

### 기본 정책 합성하기

### 부가 정책 적용하기

### 기본 정책과 부가 정책 합성하기

### 새로운 정책 추가하기

### 객체 합성이 클래스 상속보다 더 좋은 방법이다.

## 믹스인

- 믹스인은 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법

- Ruby, 스칼라, PHP 등에 구현되어 있음

  