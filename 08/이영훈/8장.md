# 의존성 관리하기
> 훌륭한 객체지향 설계란 객체가 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계다.  
> 그리고 지금까지 설명한 것처럼 이런 설계를 창조하는 데 있어서의 **핵심은 의존성을 관리하는 것이다.**

## 의존성 이해하기
- 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다
  - 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
  - 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.
- 의존성은 방향성을 가지며 항상 단방향이다.
- 두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미한다. 따라서 의존성은 **변경에 의한 영향의 전파 가능성을 암시**한다.

### 의존성 전이
한 요소가 다른 요소에 의존할 경우 다른 요소가 의존하는 요소에 대해서도 의존하게 된다는 것
- 의존성이 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다.
- 직접 의존성  
  한 요소가 다른 요소에 직접 의존하는 경우
- 간접 의존성  
  직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우
- 의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성이다.

### 런타임 의존성과 컴파일타임 의존성
- 런타임 의존성과 컴파일타임 의존성은 다를 수 있다.
- 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다. (다형성)
- 유연하고 재사용 가능한 설계를 창조하기 위해서는 
- **동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 한다.**

### 컨텍스트 독립성
클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안 된다. 구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문이다.  
- 컨텍스트 독립성  
  클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다.

### 의존성 해결하기
- 의존성 해결  
  컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것
- 의존성 해결의 방법
  - 객체를 생성하는 시점에 생성자를 통해 의존성 해결
  - 객체 생성 후 setter 메서드를 통해 의존성 해결
    - 실행 시점에 의존 대상을 변경할 수 있기 때문에 설계를 좀 더 유연하게 만들 수 있다.
    - 단점은 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에 객체를 생성하고 의존 대상을 설정하기 전까지는 객체의 상태가 불완전할 수 있다는 점이다.(NullPointerExcrption 등..)
    - 생성자에서 객체를 생성해주는 방법으로 보완할 수 있다.
  - 메서드 실행 시 인자를 이용해 의존성 해결
    - 협력 대상에 대해 지속적으로 의존 관계를 맺을 필요 없이 메서드가 실행되는 동안만 일시적으로 의존 관계가 존재해도 무방한 경우
    - 메서드가 실행될 때마가 의존 대상이 매번 달라져야 하는 경우에 유용
  
## 유연한 설계
### 의존성과 결합도
바람직한 의존성은 재사용성과 관련이 있다. 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못한 것이다.
다시 말해 컨텍스트에 독립적인 의존성이 바람직한 의존성이다.  
   
어떤 두 요소 사이에 존재하는 의존성이 바람직할 때 두 요소가 느슨한 결합도(loose coupling) 또는 약한 결합도(weak coupling)를 가진다고 말한다.  
두 요소 사이의 의존성이 바람직하지 못할 때 단단한 결합도(tight coupling) 또는 강한 결합도(strong coupling)를 가진다고 말한다.

### 지식이 결합을 낳는다
결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.

### 추상화에 의존하라
추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.  
추상화를 사용하면 현재 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다.
- 추상화와 결합도 관점에서 의존 대상의 구분
  - 구체 클래스 의존성(concrete class dependency)
  - 추상 클래스 의존성(abstract class dependency)
  - 인터페이스 의존성(interface dependency)
의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다.

### 명시적인 의존성
클래스 내부에서 구체 클래스에 의존한다면 외부에선 추상 클래스에 의존한다고 하더라도 구체 클래스에 의존하고 있는 것과 같다.
- 명시적인 의존성(explicit dependency)  
  모든 경우에 의존성이 명시적으로 퍼블릭 인터페이스에 노출되는 경우
- 숨겨진 의존성(hidden dependency)  
  의존성이 퍼블릭 인터페이스에 표현되지 않는 경우  
의존성이 명시적이지 않으면 의존성 파악을 위해 내부 구현을 직접 살펴볼 수밖에 없다.  
> 의존성은 명시적으로 표현돼야 한다. 의존성을 구현 내부에 숨겨두지 마라.

### new는 해롭다
결합도 측면에서 new가 해로운 이유는 크게 두 가지다.
- new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다. new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수밖에 없기 때문에 결합도가 높아진다.
- new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다.
> 구체 클래스에 직접 의존하면 결합도가 높아진다는 사실을 기억하라.  
> new는 결합도를 높이기 때문에 해롭다.

해결 방법은 인스턴스를 생성하는 로직과 생선된 인스턴스를 사용하는 로직을 분리하는 것이다.  
방법은 위의 [의존성 해결하기]부분과 같다.

### 가끔은 생성해도 무방하다
주로 협력하는 기본 객체를 설정하고 싶은 경우에는 객체 인스턴스를 직접 생성하는 방법이 유용할 수도 있다.  
중복 코드를 줄이고 사용성을 좋게 할 수 있는 경우 사용한다.  
메서드를 오버로딩하는 경우에도 사용할 수 있다.  
   
결합도와 사용성은 트레이드오프 대상이다.

### 표준 클래스에 대한 의존은 해롭지 않다
변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다.  
의존성이 불편한 이유는 그것이 항상 변경에 대한 영향을 암시하기 때문이다.

### 조합 가능한 행동
유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어낼 수 있는 설계다.
