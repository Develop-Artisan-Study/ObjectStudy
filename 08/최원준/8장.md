# 의존성 관리하기

## 의존성 이해하기

### 변경과 의존성

- 어떤 객체가 협력하기 위해 다른 객체를 필요할 때 두 객체 사이에 의존성이 존재하게 된다.
- 실행 시점
  - 의존하는 객체가 정상적으로 동작하기 위해서는 의존 대상 객체가 반드시 존재한다.
- 구현 시점
  - 의존 대상 격체가 변경될 경우 의존하는 객체도 함께 변경된다.

### 의존성 전이

- 의존성은 전이될 수 있다
- A가 B, C, D에 의존하면 A에 의존하는 E는 B,C,D에 대한 의존도 함께 갖게 된다.
- 의존성은 함께 변경될 수 있는 가능성을 의미하기 때문에 모든 경우에 의존성이 전이되지는 않음

### 런타임 의존성과 컴파일타임 의존성

- 컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다.
- 런타임 의존성이 다루는 것은 객체 사이의 의존성이며 컴파일은 클래스 사이의 의존성이다.
- 다형성을 이용시 런타임과 컴파일시의 의존성이 다를 수 있다.

### 컨텍스트 독립성

- 클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다.
- 클래스가 사용될 특정한 문맥에 대해 최소한의 가정으로만 이뤄져 있다면 재사용하기가 쉬워진다.

### 의존성 해결하기

- 컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임으로 교체하는 것을 의존성 해결이라고 부른다.
- 일반적으로 다음 세 가지 방법을 통해 해결한다.
  - 객체를 생성하는 시점에 생성자를 통해 의존성 해결
  - 객체 생성 후 setter 메서드를 통해 의존성 해결
  - 메서드 실행 시 인자를 이용해 의존성 해결

## 유연한 설계

### 의존성과 결합도

- 의존성은 재사용성과 관련이 있다.
- 바람직한 의존성과 그렇지 않은 의존성을 나누는 기준을 결합도라고 한다.
- 의존성이 바람직할 때 느슨한 결합도, 그렇지 않을 때 강한 결합도라고 부르곤 한다.

### 지식이 결합을 낳는다.

- 해당 객체에 대해 얼마나 알고 있느냐에 따라 결합도가 달라진다.
- 협력하는 대상에 대해서 덜 알아야 한다.

### 표준 클래스에 대한 의존은 해롭지 않다.

- 왜냐하면 표준 클래스는 바뀌지 않기 때문

### 조합 가능한 행동

- 여러가지 컨텍스트들이 합쳐져서 하나의 행동을 이끌어낼 수 있어야 한다.

  



