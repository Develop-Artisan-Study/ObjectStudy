# 역할, 책임, 협력

> 책임과 역할을 중심으로 협력을 바라보는 것이  
> 바로 변경과 확장이 용이한 유연한 설계로 나아가는 첫걸음이다.  

* 객체지향 패러다임 관점에서 핵심은 **역할(role)**, **책임(responsibility)**, **협력(collaboration)**  
<br>

* 협력(collaboration)  
  객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용  
* 책임(responsibility)  
  객체가 협력에 참여하기 위해 수행하는 로직
* 역할(role)  
  객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 행위  
<br>

* 메시지 전송(message sending)  
  객체 사이의 협력을 위해 사용할 수 있는 유일한 수단. 객체는 다른 객체의 상세한 내부 구현에 직접 접근할 수 없기 때문에 오직 메시지 전송을 통해서만 자신의 요청을 전달할 수 있다.  
  요청 : 메소드 콜  
  응답 : 메소드 실행 후 리턴  
<br>

* 결과적으로 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 **캡슐화** 하는 것  
<br>

> 협력은 객체를 설계하는 데 필요한 일종의 문맥(context)을 제공한다.  

<br>

* 책임은 **하는 것(doing)** 과 **아는 것(knowing)** 의 두 가지 범주로 나누어 세분화하고 있다.  
* 협력이 중요한 이유는 객체에게 할당할 책임을 결정할 수 있는 문맥을 제공하기 때문  
> 객체에게 얼마나 적절한 책임을 할당하느냐가 설계의 전체적인 품질을 결정한다.  
> 객체의 구현 방법은 상대적으로 책임보다는 덜 중요하며 책임을 결정한 다음에 고민해도 늦지 않다.  
* 정보 전문가 패턴  
  책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 쩐문가에게 그 책임을 할당하는 것  

<br>

* 책임 주도 설계(Responsibility-Driven Design, RDD)  
  책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법  
* 메시지가 객체를 결정한다  
  이러면,
    * 객체가 최소한의 인터페이스를 가질 수 있게 된다
    * 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다  

<br>

* 캡슐화를 위반하지 않도록 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 한다.
> 협력이 객체의 행동을 결정하고 행동이 상태를 결정한다. 그리고 그 행동이 바로 객체의 책임이 된다.  

<br>

* 협력을 모델링할 때는 특정한 객체가 아니라 역할에게 책임을 할당한다고 생각하는 게 좋다.
* 책임을 수행하는 대상이 한 종류라면 역할 = 객체가 된다.
* 추상화를 통해 다양한 역할을 하나의 추상화 객체로 표현할 수 있다.


<br>

---
객체는 다양한 역할을 가질 수 있다. 객체는 협력에 참여할 때 협력 안에서 하나의 역할로 보여진다. 객체가 다른 협력에 참여할 때는 다른 역할로 보여진다. 협력의 관점에서 **동일한 역할을 수행하는 객체들은 서로 대체 가능**하다. 역할은 특정한 객체의 종류를 캡슐화하기 때문에 **동일한 역할을 수행하고 계약을 준수하는 대체 가능한 객체들은 다형적**이다.