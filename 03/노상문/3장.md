#Chapter 3 역할,책임, 협력
## 2장 요약
- 클래스, 추상 클래스, 인터페이스를 조합해서 객체지향 프로그램을 구조화하는 기본적인 방법과 상속을 이용해 다형성을 구현하는 기법.
- 다형성이 지연 바인딩이라는 메커니즘을 통해 구현된다는 사실 설명.
- 상속은 코드를 재사용할 수 있는 가장 널리 알려진 방법이지만 캡슐화의 측면에서 합성이 더 좋은 방법이라는 사실.
- 유연한 객체지향 프로그램은 컴파일 시간 의존성과 실행 시간 의존성이 달라야한다는 것.<br><br>

- 객체지향 패러다임의 관점에서 핵심은 역할(role), 책임(responsibility),협력(collaboration)이다.<br>
클래스,상속 지연 바인딩이 중요하지 않다기보단 다분히 구현 측면에 치우쳐 있다.<br><br>
  
- 객체지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이다. <br>
객체지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다.<bR>
  클래스와 상속은 객체들의 책임과 협력이 어느 정도 자리를 잡은 후에 사용할 수 있는 구현 메커니즘일 뿐이다.<br><bR>
  어플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 <br>
  너무 이른 시기에 구현에 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.<br><br>
  역할,책임,협력이 객체지향에서 가장 중요하며, <br>
  이들이 제자리를 찾지 못한 상태라면 응집도 높은 클래스와 중복 없는 상속 계층을 구현한다고 하더라도 어플리케이션이 잘못된 방향으로 갈 수 있다.<br>
  

## 협력
### 영화 예매 시스템 돌아보기
- 사용자가 영화 예매 시스템을 통해 영화를 예매할 수 있게 하려면 다양한 객체들이 참여하는 협력을 구축해야 한다.<br>
- 객체지향 원칙을 따르는 애플리케이션의 제어 흐름은 어떤 하나의 객체에 의해 통제되지 않고 다양한 객체들 사이에 균형 있게 분배되는 것이 일반적이다.
-객체들은 요청의 흐름을 따라 자신에게 분배된 로직을 실행하면서 어플리케이션의 전체 기능을 완성한다.<br><br>
  
- 다양한 객체들이 영화 예매라는 기능을 구현하기 위해 메시지를 주고 받으면서 상호작용하는 것을 보았을 것이다.<bR>
이처럼 객체들이 어플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 <b style="color:orange">협력</b>이라고 한다.<br><br>
- 객체가 협력에 참여하기 위해 수행하는 로직은 <b style="color:yellow">책임</b>이라고 부른다.<br><br>
- 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수해하는 <b style="color:green">역할</b>을 구성한다.
<br><br>
  
### 협력
- 객체지향 시스템은 자율적인 객체들의 공동체다.<br>
- 객체는 고립된 존재가 아니라 시스템의 기능이라는 더 큰 목표를 달성하기 위해 다른 객체와협력하는 사회적인 존재다.
- 협력은 객체지향의 세계에서 기능을 구현할 수 있는 유일한 방법이다.<br>
- 두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작된다. <br>
- <b style="color:yellow">메시지 전송(message sending)</b>은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이다.<br>
 객체는 다른 객체의 상세한 내부 구현에 직접 접근할 수 없기 때문에 오직 메시지 전송을 통해서만 자신의 요청을 전달할 수 있다.<br><br>
  
> 협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다. 한 객체는 어떤 것이 필요할 때 다른 객체에게 전적으로 위임하거나 서로 협력한다.<br>
> 즉 두 객체가 상호 작용을 통해 더 큰 책임을 수행하는 것이다.<br> 
> 객체 사이의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다.

- 메시지를 수신한 객체는 <b style="color:yellow">메서드</b>를 싱행해 요청에 응답한다.<br>
여기서 객체가 메시지를 처리할 방법을 스스로 선택한다는 점이 중요하다. <br>
  외부의 객체는 오직 메세지만 전송할 수 있을 뿐이며 메시지를 어떻게 처리할지는 메시지를 수신한 객체가 직접 결정한다.<Br>
  이것은 객체가 자신의 일을 스스로 처리할 수 있는 자율적인 존재라는 것을 의미한다.<br><br>
  예를 들어, `Screening`과 `Movie`의 협력 관계를 보면 `Screening`은 `Movie`에 `calculateMovieFee` 메시지를 전송함으로써 예매자 한 명의 요금 계산을 요청한다.<br>
  `Screening`이 `Movie`에게 처리를 위임하는 이유는 요금을 계산하는 데 필요한 기본 요금과 할인 정책을 가장 잘 알고 있는 객체가 `Movie`이기 때문이다.<br>
  요금을 계산하는 작업을 `Screening`이 수행한다면 `Movie`의 인스턴스 변수인 `fee`와 `discountPolicy`에 직접 접근해야만 할 것이다.<br>
  이 경우 `Screening`은 `Movie`의 내부 구현에 결합된다.<br><br>
  이렇게 되면 가장 큰 문제점은 `Movie`의 자율성 훼손이다.<br>
  자율적인 객체란 자신의 상태를 직접 관리하고 스스로의 결정에 따라 행동하는 객체다.<br>
  객체의 자율성을 보장하기 위해서는 필요한 정보와 정보에 기반한 행동을 같은 객체 안에 모아놓아야 한다.<br>
  하지만 `Screening`이 `Movie`의 정보를 이용해 요금을 계싼할 경우 정보와 행동이 `Movie`와 `Screening`이 라는 별도의 객체로 나뉜다.<Br>
  결과적으로 `Movie`는 자율적인 존재가 아니라 수동적인 존재로 변질된다. <br><br>
  `Movie`가 자율적인 존재가 되려면 자신이 알고 있는 정보를 이용해서 스스로 요금을 계산해야 한다.<br>
  이것이 `Screening`이 `Movie`에게 요금을 계산하도록 위임하는 이유다.<br>
  자신이 할수 없는일을 다른 객체에 위임하면 협력에 참여하는 객체들의 전체적인 자율성을 향상 시킬 있다.<br><br>
  결과적으로 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 <b style="color:yellow">캡슐화</b> 하는 것이다.<Br>
  캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있기 때문에 자율적인 객체는 변경하기도 쉬워진다.<br>
  `Screening`이 요금을 계산하기 위해 `Movie`의 내부 구현에 직접 접근한다는 것은 캡슐화의 원칙을 위반한다.<br>
  이 경우 `Movie`의 내부 구현을 바꾸면 `Screening`도 영향을 받게 된다.<br>
  반면 `Movie`가 자신의 정보를 바탕으로 요금을 직접 계산하면 `Screening`과 `Movie`사이의 결합도를 느슨하게 유지할 수 있으며, <br>
  `Movie`에 대한 변경의 여파가 `Screening` 쪽으로 확산되는 것을 막을 수 있다. <br><br>
  정리하자면 자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부 도움이 필요한 경우 적절한 객체에게 메시지를 전송해서 협력을 요청한다.<br>
  메시지를 수신한 객체 역시 메시지를 처리하던 중에 직접 처리할 수 없는 정보나 행동이 필요한 경우 또 다른 객체에게 도움을 요청한다.<Br>
  이처럼 객체들 사이의 협력을 구성하는 일련의 요청과 응답의 흐름을 통해 어플리케이션의 기능이 구현된다.
  
### 협력이 설계를 위한 문맥을 결정한다.<br>
- 객체란 상태와 행동을 함계 캡슐화하는 실행 단위다.<bR>
그렇다면 객체가 가질 수 있는 상태와 행동을 어떤 기준으로 결정해야 할까?<br>
  객체를 설계할 때 어떤 행동과 상태를 할당했다면 그 이유는?<br><br>
  
- 어떤 객체도 섬이 아니다. [Beck]<br>
어플리케이션 안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다.<br>
  그 객체가 어떤 협력에 참여하고 있기 때문이다.<br>
  그리고 객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 보유하고 있기 때문이다.<br><br>
  결론적으로 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.<bR>
  협력이 바뀌면 객체가 제공해야하는 행동 역시 바뀌어야 한다.<br>
  협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다.<br><br>
  `Movie`객체는 어떤 행동을 수행할 수 있어야할까? <br>
  영화라는 단어를 들었을 때 대부분의 사람들은 극장에서 영화를 상영하는 장면을 상상할 것이고 자연스럽게 `Movie`객체가 `play` 라는 행동을 수행할 것이라고 생각한다.<br>
  그러나 영화 예매 시스템 안의 `Movie`는 영화를 상영하기 위한 어떤 코드도 포함되어 있지않다.<br>
  `Movie` 에 포함된 대부분의 메서드는 요금을 계산하는 행동과 관련되어 있다.<br>
  이것은 `Movie`가 영화를 예매하기 위한 협력에 참여하고 있고 그 안에서는 요금을 꼐산하는 책임을 지고 있기 때문이다.<br><br>
  
`Movie`의 행동을 결정하는 것은 영화 예매를 위한 협력이다.<br>
협력이라는 문맥을 고려하지 않고 `Movie`의 행동을 결정하는 것은 아무런 의미가 없다.<br>
협력이 존재하기 때문에 객체가 존재하는 것이다.<br><br>
객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.<br>
객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정된다.<br>
객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문에 객체가 수행하는 행동에 필요한 상태도 함께 가지고 있어야 한다.<br><br>

`Movie`가 기본 요금인 `fee`와 할인 정책인 `discountPolicy`라는 인스턴스 변수를 상태의 일부로 포함하는 이유는 요금 계산이라는 행동을 수행하는 데 이 정보들이 필요하기 때문이다.<br><br>

```java
public class Movie{
    private Money fee;
    private DiscountPolicy discountPolicy;
    
    public Money calculateMovieFee(Screening screening){
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

상태는 객체가 행동하는데 필요한 정보에 의해 결정되고 행동은 협력 안에서 객체가 처리할 메시지로 결정된다.<br>
결과적으로는 객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두를 결정한다.<br>
따라서 협력은 객체를 설계하는 데 필요한 일종의 <b style="color:yellow">문맥(context)</b>을 제공한다.

## 책임
### 책임이란 무엇인가?
- 협력에 참여하기 위해 객체가 수행하는 행동을 <b style="color:orange">책임</b>이라고 부른다.<br><br>
책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합으로, 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장이다.<br>
  즉, 객체의 챔익은 객체가 '무엇을 알고 있는가' 와 '무엇을 할 수 있는가' 로 구성된다.<br><br>
  크레이그 라만(Craig Larman)은 이러한 분류 체계에 따라 객체의 책임을 크게 <b style="color:orange">'하는 것(doing)'</b>과 <b style="color:yellow">'아는 것(knowing)'</b>의 두 가지 범주로 나누어 세분화하고 있다.<br><br>  
 - 하는 것
   - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것.
   - 다른 객체의 행동을 시작시키는 것.
   - 다른 객체의 활동을 제어하고 조절하는 것.<br><br>
- 아는 것
   - 사적인 정보에 관해 아는 것.
   - 관련된 객체에 관해 아는 것.
   - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것.<br><bR>
  영화 예매 시스템에서 `Screening`의 책임은 무엇인가?<bR>
  영화를 예매하는 것이다. <br>`Movie`의 책임은 무엇인가? 요금을 계산하는 것이다.<br>
     `Screeining`은 영화를 예매할 수 있어야 한다.<Br>
     이것은 아는 것과 관련된 책임이다.<br>
     `Movie`는 예매 가격을 계산할 책임을 진다. 이것은 하는 것과 관련된 책임이다.<br>
     또한 가격과 어떤 할인 정책이 적용됐는지도 알고 있어야 한다, 이것은 아는것과 관련된 책임이다.<br><br>
     
<table>
<tr>
<td colspan="2">Screening</td>
</tr>
<tr>
<td>상영 정보를 알고 있다.</td>
<td>Movie</td></tr>
<tr>
<td>예매 정보를 생성한다. </td>
<td></td></tr></table>

<table>
<tr>
<td colspan="2">Movie</td>
</tr>
<tr>
<td>영화 정보를 알고 있다.</td>
<td>DiscountPolicy</td></tr>
<tr>
<td>가격을 계산한다.</td>
<td></td></tr></table>

<table>
<tr>
<td colspan="2">DiscountPolicy</td>
</tr>
<tr>
<td>할일 정책을 알고 있다.</td>
<td>DiscountCondition</td></tr>
<tr>
<td>할인된 가격을 계산한다.</td>
<td></td></tr></table>

<table>
<tr>
<td colspan="2">DiscountCondition</td>
</tr>
<tr>
<td>할일 조건을 알고 있다.</td>
<td>Screening</td></tr>
<tr>
<td>할인 여부를 판단한다. </td>
<td></td></tr></table>

-------
`Screening`이 `reserve` 메세지를 수신하고 `movie`를 인스턴스 변수로 포함하는 이유는 협력 안에서 영화를 예매할 책임을 수행해야 하기 때문이다.<br>
`Movie `가 `calculateMovieFee`메시지를 수신할 수 있고 `fee`와 `discountPolicy`를 속성으로 가지는 이유는 협력 안에서 가격을 계산할 책임을 할당받았기 때문이다.<br>
이처럼 협력 안에서 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다.<br><br>

일반적으로 책임과 메시지의 크기는 다르다.<br>
책임은 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술하기 때문에 메시지보다 추상적이고 개념적으로도 더 크다.<br>
청므에는 단순한 책임이라고 생각했던 것이 여러 개의 메시지로 분할되기도하고 하나의 객체가 수행할 수 있다고 생각했던 책임이 나중에는 여러 객체들이 협력해야하만 하는 커다란 책임으로 자라는 것이 일반적이다.<br><br>
여기서 중요한 사실은 책임의 관점에서 '아는 것'과 '하는 것'이 밀접하게 연관돼 있다는 점이다.<Br>
객체는 자신이 맡은 책임을 수행하는 데 필요한 정보를 알고 있을 책임이 있다.<br>
또한 객체는 자신이 할 수 없는 작업을 도와줄 객체를 알고 있을 책임이 있따.<br>
어떤 책임을 수행하기 위해서는 그 책임을 수행하는 데 필요한 정보도 함께 알아야 할 책임이 있다는 것이다.<br>
이것은 객체에게 책임을 할당하기 위한 가장 기본적인 원칙에 대한 힌트를 제공한다. <br><br>
책임은 객체지향의 설계의 핵심이다.<bR>
"객체 지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는것"- 크레이그 라만<bR>
사실 협력이 중요한 이유는 객체에게 할당한 책임을 결정할 수 있는 문맥을 제공하기 때문이다.<br>
적절한 협력이 적절한 책임을 제공하고, 적절한 책임을 적절한 객체에게 할당해야하만 단순하고 유연한 설계를 창조할 수 있다.

<details><summary>CRC 카드</summary>
CRC 카드는  10 x15cm 정도의 작은 인덱스 카드를 말한다.
CRC 라는 단어는 후보(Candidate),책임(Responsibility), 협력자 (Collaborator)의 첫 글자를 따서 만들어졌다.<br>
CRC 카드는 선이 없는 면과 3개의 구획으로 나뉜 면으로 구성된다.<br>
하나의 CRC 카드는 협력에 참여하는 하나의 후보를 표현한다.<br>
후보는 역할 객체,클래스 어떤 것이라도 될 수 있다.<br>
카드의 선이 없는 면에는 후보의 목적을 기술한다.<br>
목적은 후보가 외부에 제공해야 하는 서비스를 하나의 문장으로 표현한다.<br>

선이 있는 다른 면의 상단에는 후보 이름을 적는다. 좌측 하당에는 목적을 좀 덧 세분화해서 무엇을 알고 무엇을 해야 하는지에 대한 책임을 차례대로 적는다.<br>
카드의 우측에는 책임을 수행하면서 함께 협력할 협력자들을 나열한다.<br>
협력자는 후보가 자신의 책임을 완수하기 위해 정보나 기능을 요청할 대상 후보를 의미한다.<br><br>

<table>
<tr>
<td colspan="2">DiscountCondition  <b style="color:orange">candidate</b> </td>
</tr>
<tr>
<td>할일 조건을 알고 있다.<b style="color:orange">Responsibility</b></td>
<td>Screening<b style="color:orange">Collaborator</b></td></tr>
<tr>
<td>할인 여부를 판단한다. </td>
<td></td></tr></table><br>
</details>

### 책임 할당
- 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다.<br>
이를 책임 할당을 위한 `INFORMATION EXPERT( 정보 전문가)`패턴이라고 부른다.<BR>
  
정보 전문가에게 책임을 할당하는 것은 일상 생활에서도 도움을 요청하는 방식과도 유사하다.<BR>
일상 생활 에서도 어떤 도움이 필요한 경우 그 일을 처리하는 데 필요한 지식과 방법을 가장 잘 알고 있는 전문가에게 도움을 청한다.<BR>
객체의 세계에서도 마찬가지다.<BR>
객체들 역시 협력에 필요한 지식과 방법을 가장 잘 알고 있는 객체에게 도움을 요청한다.<BR>
요청에 응답하기 위해 필요한 이 행동이 객체가 수행할 책임으로 이어지는 것이다.<BR><BR>
따라서 객체에게 책임을 할당하기 위해서는 먼저 협력이라는 문맥을 정의해야 한다.<BR>
협력을 설꼐하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것이다.<BR>
객체지향 설계는 시스템의 책임을 완료하는 데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰진다.<Br><BR>
객체가 책임을 수행하게 하는 유일한 방법은 메시지를 전송하는 것이므로 책임을 할당한다는 것은 메시지의 이름을 결정하는 것과 같다.
EX) 예매하라.
메시지를 선택했으면 메시지를 처리할 적절한 객체를 선택해야한다.<BR>
기본 전략은 정보 전문가에게 책임을 할당하는 것이다.<BR>
그를 위해서는 이 정보를 소유하고 있거나 해당 정보의 소유자를 가장 잘 알고 있는 전문가는 누구인지를 생각해봐야한다.<BR>
EX)`Screening`<br><br>

객체 지향 설계는 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반보적인 과정을 통해 이뤄진다.<br>
 그리고 이런 메시지가 메시지를 수신할 객체의 책임을 결정한다. <br><br>
이렇게 결정된 메시지가 객체의 퍼블릭 인터페이스를 구성한다는 것 역시 눈겨여봐야한다.<br>
협력을 설계하면서 객체의 책임을 식별해 나가는 과정에서 최종적으로 얻게 되는 결과물은 시스템을 구성하는 객체들의 언터페이스와 오퍼레이션의 목록이다.<br>
앞 장에서 살펴본 구현은 정보 전문가에게 책임을 할당하는 과정을 거쳐 얻어낸 협력을 코드로 구현한 것이다.<br><br>
물론 모든 책임 할당 과정이 이렇게 단순한 것은 아니다.<Br>
어떤 경우에는 응집도와 결합도의 관점에서 정보 전문가가 아닌 다른 객체에게 책임을 할당하는 것이 더 적절한 경우도 있다.<br>
하지만 기본적인 전략은 책임을 수행할 정보 전문가를 찾는 것이다.<br>
정보 전문가에게 책임을 할당하는 것만으로도 상태와 행동을 함께 가지는 객체를 만들 가능성이 높아지기 때문이다.<br>

### 책임 주도 설계
- 지금까지 살펴본 내용의 요점은 협력을 설계하기 위해서는 책임에 초점을 맞춰야 한다는 것이다.<br>
어떤 책임을 선택하느냐가 전체적인 설계의 방향과 흐름을 결정한다. <br>
  이처럼 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 <b style="color:orange">책임 주도 설계(Responsibility-Driven- Design,RDD)</b>라고 부른다.<br><br>
  다음은 책임 주도 설계 방법의 과정을 정리한 것이다.<br>
  - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
  - 시스템 책임을 더 작은 책임으로 분할한다.<br>
  - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.<br>
  - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.<br>
  - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.<br><br>
  
협력은 객체를 설꼐하기 위한 구체적인 문맥을 제공한다.<br>
협력이 책임을 이끌어내고 책임이 협력에 참여할 객체를 결정한다.<br>
책임 주도 설계는 자연스럽게 객체의 구현이 아닌 책임에 집중할 수 있게 한다.<br>
구현이 아닌 책임에 집중하는 것이 중요한 이유는 유연하고 견고한 객체지향 시스템을 위해 가장 중요한 재료가 바로 책임이기 때문이다.<br><br>

이제 책임을 할당할 때 고려해야 하는 두 가지 요소를 소개하는 것으로 책임에 대한 소개를 마치려고 한다.<br><br>
하나는 <b style="color:orange"> 메시지가 객체를 결정한다는 것</b> 이고<bR><br>
하나는 <b style="color:orange"> 행동이 상태를 결정한다는 것</b>이다.

### 메세지가 객체를 결정한다.

- 객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택했다는 것이 중요하다.<br>
다시 말해 객체가 메시지를 선택했다는 것이 아니라 메시지가 객체를 선택하게 했다.<br><br>
  메시지가 객체를 선택하게 해야 하는 두 가지 중요한 이유가 있다.<Br><br>
  첫쨰, 객체가 <b style="color:orange">최소한의 인터페이스 (minimal interface)</b>를 가질 수 있게 된다.<Br>
  필요한 메시지가 식별될 때 까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문에 객체는 어플리케이션에 크지도, 작지도 않은 꼭 필요한 크기의 퍼블릭 인ㅌ터페이스를 가질 수 있다.<br><br>
  둘째, 객체는 충분히 <b style="color:orange">추상적인 인터페이스(abstract interface)</b>를 가질 수 있게 된다.<br>
  객체의 인터페이스는 무엇(what)을 하는지는 표현해야 하지만 어떻게(how)는 수행하는지를 노출해서는 안된다.<Br>
  메시지는 외부의 객체가 요청하는 무언가를 의미하기 때문에 메시지를 먼저 식별하면 무엇을 수행할지에 초점을 맞추는 인터페이스를 얻을 수 있다.<bR>
  영화 예메 시스템의 경우 "예매하라"라는 메시지를 선택하는 것으로 설계를 시작했다는 것을 기억해야 한다.<br>
  협력을 위한 예매하라라는 메시지가 필요하다는 결정을 내린 후에 그 메시지를 수신할 적절한 객체로 `Screening`을 선택했다.<br>
  그리고 `Screening`이 가격을 계산하라라는 메시지를 전송해야 한다는 사실을 결정한 후에 그 메시지를 수신할 수 있는 객체로 `Movie`를 선택했다.<br><br>
  결과적으로 협력을 구성하는 객체들의 인터페이스는 충분히 추상적인 동시에 최소한의 크기를 유지할 수 있었다.<br><br>
  객체가 충분히 추상적이면서 미니멀리즘을 따르는 인터페이스를 가지게 하고 싶다면 메시지가 객체를 선택하게 하라.<br><br>
  
### 행동이 상태를 결정한다.
- 객체가 존재하는 이유는 협력에 참여 하기 위해서다.<br>
따라서 객체는 협력에 필요한 행동을 제공해야 한다.<br>
  객체를 객체답게 만드는 것은 객체의 상태가 아니라 객체가 다른 객체에게 제공하는 행동이다.<br><br>
  객체의 행동은 객체가 협력에 참여할 수 있는 유일항 방법이다.<br>
   객체가 협력에 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동이다.<br>
  얼마나 적절한 객체를 창조했느냐는 얼마나 절적할 책임을 할당했느냐에 달려있고, 책임이 얼마나 적절한지는 협력에 얼마나 적절한가를 달려있다.<br><br>
  객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것이다.<br>
  초보자들은 먼저 객체에 필요한 상태가 무엇인지를 결정하고, 그 후에 상태에 필요한 행동을 결정한다.<br>
  이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다.<br>
  객체의 내부 구현을 변경하면 퍼블릭 인터페이스도 함께 변경되고, 결국 객체에 의존하는 클라이언트로 변경의 영향이 전파된다.<br>
  이를 객체의 내부 구현에 초점을 맞춘 설계 방법을 <b style="color:orange">데이터-주도 설계(Data-Driven Design)</b>이라고 부르기도 했다.<bR><br>
  캡슐화를 위반하지 않도록 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 한다.<br>
  협력 관계 속에서 다른 객체에게 무엇을 제공해야 하고 다른 객체로부터 무엇을 얻어야 하는지를 고민해야만 훌륭한 책임을 수확할 수 있다.<br>
  개별 객체의 상태와 행동이 아닌 시스템의 기능을 구현하기 위한 협력에 초점을 맞춰야만 응집도가 높고 결합도가 낮은 객체들을 창조할 수 있다.<ㅠㄱ>
  상태는 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료일 뿐이다.<br><br>

<b style="color:orange">중요한 것은 상태가 아닌 행동이다.</b><br>
객체가 가질 수 있는 상태는 행동을 결정하고 나서야 비로소 결정할 수 있다.<br>
협력이 객체의 행동을 결정하고 해동이 상태를 결정한다. 그리고 그 행동이 바로 객체의 책임이 된다.<br>


## 역할
### 역할과 협력
- 객체는 협력이라는 주어진 문맥 안에서 특정한 목적을 갖게 된다.<br>
객체의 목적은 협력 안에서 객체가 맡게 되는 책임의 집합으로 표시된다.<br>
  이처럼 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 역할 이라고 부른다.<br><br>
  실제로 협력을 모델링할 때는 특정한 객체가 아니라 역할에게 책임을 할당한다고 생각하는게 좋다.<br><br>
  
  - 첫번째 단계는 영화를 예매할 수 있는 적절한 역할이 무엇인가를 찾는 것.
  - 두번째 단계는 단계는 역할을 수행할 객체로 `Screening` 인스턴스를 선택하는 것이다.<br>
  역할에 특별한 이름을 부여하지는 않았지만 실제로는 익명의 역할을 찾고 그 역할을 수행 할 수 있는 객체를 선택하는 방식으로 설계가 진행됐다고 생각하는 것이 자연스럽다.<br>
    역할에 특별한 이름을 부여하지는 않았지만 객체를 수용할 수 있는 위치로서 역할이라는 개념은 여전히 존재한다.<br>
    그렇다면 어떤 이유로 역할이라는 개념을 이용해서 설계 과정을 더 번거롭게 만드는 것일까?<bR>
    어차피 역할이 없어도 객체만으로 충분히 협력을 설계할 수 있지 않을까?<br><Br>
    
### 유연하고 재사용 가능한 협력
- 역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문이다.<br>
이해를 돕기 위해 역할이라는 개념을 고려하지 않고 객체에게 책임을 할당한다고 가정해보자.<br>
  `Movie`가 가격을 계산하기 위해서는 할인 요금이 필요하다.<br>
  따라서 다음과 같이 할인 요금을 계산하라는 메시지를 전송해서 외부의 객체엑 도움을 요청한다.<br><br>
  영화 예매 도메인에는 금액 할인 정책과 비율 할인 정책이라는 두 가지 종류의 가격 할인 정책이 존재하기 때문에 `AmountDiscountPolicy` 인스턴스와 `PercentDiscountPolicy` 인스턴스라는 두 가지 종류의 객체가 할인 요금을 계산하라 메시지에 응답할 수 있어야 한다.<br>
  그렇다면 두 종류의 객체가 참여하는 협력을 개별적으로 만들어야 할까?<bR>
  안타깝게도 이런 방법으로는 두 협력을 구현하면 대부분의 코드가 중복되고 말 것이다.<br>
  프로그래밍에서 코드 중복은 모든 문제의 근원이기 때문에 이런 방법은 피해야 한다.<br><br>
  문제를 해결하기 위해서는 객체가 아닌 책임에 초점을 맞춰야 한다.<Br>
  순수하게 책임의 관점에서 두 협력을 바라보면 `AmountDiscountPOolicy`와 `PercentDiscountPolicy` 모두 할인 요금 계산이라는 동일한 책임을 수행한다는 사실을 알 수 있다.<bR>
  따라서 객체라는 존재를 지우고 할인 요금을 계산하라는 메시지에 응답할 수 있는 대표자를 생각한다면 두 협력을 하나로 통합할 수 있을 것이다.<br>
  이 대표자를 협력 안에서 두 종류의 객체를 교대로 바꿔 끼울 수 있는 일종의 슬롯으로 생각할 수 있다.<br>
  이 슬롯이 바로 역할이다.
  <br> 역할은 다른 것으로 교체할 수 있는 책임의 집합이다.<br><br>
  여기서의 역할이 두 종류의 구체적인 객체를 포괄하는 추상화 라는 점에 주목하라.<br>
  따라서 `AmountDiscountPolicy`와 `PercentDiscountPolicy`를 포괄 할 수 있는 추사엊ㄱ인 이름을 부여해야 한다.<br><br>
  역할의 이름으로  `DiscountPolicy`가 어떨까? <br><br>
  요즘은 동일한 책임을 수행하는 역할을 기반으로 두 개의 협력을 하나로 통합할 수 있다는 것이다.<br><br>
  따라서 역할을 이용하면 불필요한 중복 코드를 제거할 수 있다.<br>
  더 좋은 소식은 협력이 더 유연해졌다는 점이다.<br>
  이제는 새로운 할인 정책을 추가하기 위해 새로운 협력을 추가할 필요가 없어졌다.<br>
  `DiscountPolicy`역할을 수행할 수 잇는 어떤 객체라도 이 협력에 참여할 수 있게 됐다.<br>
  따라서 책임과 역할을 중심으로 협력을 수행할 수 있는 어떤 객체라도 이 협력에 참여할 수 있게 됐다.<br>
  따라서 책임과 역할을 중심으로 협력을 바라보는 것이 바로 변경과 확장이 용이한 유연한 설계로 나아가는 첫걸음이다.<br>
  
  <details><summary>역할의 구현</summary>
  추상화라는 말에서 예상했겟지만 역할을 구현하는 가장 일반적인 방법은 추상클래스와 인터페이스를 사용하는 것이다.<br>
  협력의 관점에서 추상 클래스와 인터페이스는 구체 클래스들이 따라야 하는 책임의 집합을 서술한 것이다.<br>
  추상 클래스는 책임의 일부를 구현해 놓은 것이고 인터페이스는 구체 클래스들이 따라야 하는 책임의 집합을 서술한 것이다.<Br>
  추상클래스는 책임의 일부를 구현해 놓은 것이고 인터페이스는 일체의 구현 없이 책임의 집합만을 나열해 놓았다는 차이가 있지만 협력의 관점에서는 둘 모두 역할을 정의할 수 있는 구현 방법이라는 공통점을 공유한다.<br><br>
  영화 예매 시스템에서 `DiscountPolicy` 는 추상클래스로 구현했다. <br>
  이것은 역할을 수행할 수 있는 모든 객체들이 공유하는 상태와 행동의 기본 구현이 존재하기 때문이다.<br>
  반면 `DiscountCondition`의 경우에는 공통의 구현이 필요없고 단지 책임의 목록만 정의하면 되기 때문에 인터페이스로 구현했다.<br>

추상 클래스와 인터페이스는 동일한 책임을 수행하는 다양한 종류의 클래스들을 협력에 참여시킬 수 있는 확장 포인트르를 제공한다.<br>
이들은 동일한 책임을 수행할 수 있는 객체들을 협력안에 수용할 수 잇는 역할이다.<br><br>
여기서 중요한 것은 역할이 다양한 종류의 객체를 수용할 수 있는 일종의 슬롯이자 구체적인 객체들의 타입을 캡슐화하는 추상화라는 것이다.<br>
일단 협력 안에서 역할이 어떤 책임을 수행해야 하는지를 결정하는 것이 중요하다.<br>
역할을 구현하는 방법은 그다음 문제다.<Br>
객체에게 중요한 것은 행동이며, 역할은 객체를 추상화해서 객체 자체가 아닌 협력에 초점을 맞출 수 있게 한다.
</details>

인터페이스 업캐스팅, 다형성, 늦은 바인딩, 상속, 컴파일 시간 의존성과 실행 시간 의존성의 차이 와 같은 다양한 기술적 메커니즘이 숨겨져있따.<br>
하지만 여기서 중요한 것은 이러한 기술적 메커니즘들이 모여 유연하고 재사용 가능한 협력을 만들 수 있는 기반을 제공한다는 것이다.<br><Br>

### 객체 대 역할
- 역할은 객체가 참여할 수 있는 일종의 슬롯이다.<br>
따라서 유용하고 재사용 가능한 설꼐라는 문맥에서 역할의 중요성은 아무리 강조해도 지나치지 않을 것이다.<br>
  그러나 오직 한 종류의 객체만 협력에 참여하는 상황에서 역할이라는 개념을 고려하는 것이 유용할까, 역할이라는 개념을 생략하고 직접 객체를 이용해 협력을 설계하는 것이 더 좋지 않을까, 이런 경우에 역할을 사용하는 것은 상황을 오히려 더 복잡하게 만드는 것은 아닐까?<br><br>
  
협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 필요가 있다면 그 후보는 역할이 되지만 단지 한 종류의 객체만이 협력에 참여할 필요가 있다면 후보는 개체가 된다.<br><br>

객체에 관해 생각할 때 '이 객체가 무슨 역할을 수행하는가 ?' 라는 자문하는 것이 도움이된다.<br>
이 질문은 객체가 어떤 형태를 띠어야 하는지, 그리고 어떤 동작을 해야 하는지에 집중할 수 있게 도와준다.<br>
지금까지 객체와 역할에 대해 막연하게 이야기를 했는데, 둘의 진짜 차이는 무엇일까? 만약 동일 종류의 객체가 하나의 역할을 항상 수행한다면 둘은 동일하다.<br>
하지만 어떤 협력에서 하나 이상의 객체가 동일한 책임을 수행할 수 있따면 역할은 서로 다른 방법으로 실행할 수 있다면 역할은 서로 다른 방법으로 실행할 수 있는 책임의 집합이 된다. <br>
역할이 프로그램이 실행될 때 소프트웨어 기계 장치에서 적절한 객체로 메워 넣을 수 있는 하나의 슬롯으로 생각할 수 있다.<br>
배우가 극중에서 믿을 수 잇는 배역을 맡아서 하려는 것처럼 객체는 의미 있는 역할을 정의하는 책임을 통해 어플리케이션의 기능을 담당하게 된다.<br>

다시 말해 협력에 적잡한 책임을 수행하는 대상이 한 종류라면 간단하게 객체로 간주한다.<br><br>
만약 여러 종류의 객체들이 참여할 수 있다면 역할이라고 부르면 된다.

- 실행 되는 동안에 협력 안에서 각자의 위치를 가지는 객체들에 대한 별칭이라고 정의하기도 한다.<br>
- 협력은 역할들의 상호작용으로 구성되고, 협력을 구성하기 위해 역할에 적합한 객체가 선택되며, 객체는 클래스를 이용해 구현되고 생성된다.<br><br>
대부분의 경우에 어떤 것이 역할이고 어떤 것이 객체인지가 또렷하게 드러나지는 않을 것.<br>
  특히 명확한 기준을 세우기 어렵고 정보가 부족한 설계 초반에는 결정을 내리기가 더욱 어려울 것이다.<br>
  애매하다면 단순하게 객체로 시작하고 반복적으로 책임과 협력을 정제해가면서 필요한 순간에 객체로부터 역할을 분리해내는 것이 가장 좋은 방법이다.<br><br>

- 처음에 특정 시나리오에 대한 협력을 구상할 때는 아마도 도메인 모델에 있는 개념들을 후보로 선택해 직접 책임을 할당할 것이다.<br>
다양한 시나리오를 설꼐로 옮기면서 협력을 지속적으로 정제하다 보면 두 협력이 거의 유사한 구조를 보인다는 것을 발견하게 될 것이다.<br>
  이 경우 두 협력을 하나로 합치면서 두 객체를 포괄할 수 있는 역할을 고려해서 객체를 역할로 대체할 수 있다.<bR><br>
  
다양한 객체들이 협력에 참여한다는 것이 확실하다면 역할로 시작하라.<br>
하지만 모든 것이 안개 속에 둘러싸여 있고 정확한 결정을 내리기 어려운 상황이라면 구체적인 객체로 시작하라.<br>
다양한 시나리오를 탐색하고 유사한 협력들을 단순화하고 합치다 보면 자연스럽게 역할이 그 모습을 드러낼 것이다.<br><br>
역할은 객체와 클래스에 비해 상대적으로 덜 알려져 있으며 그다지 주목받지 못한 개념인 것이 사실이다.<br>
대부분의 객체지향 언어들은 역할을 구현할 수 있는 언어적인 편의 장치를 제공하지 않는다.<br>
 그럼에도 유연하고 확장 가능하며 일관된 구조를 가지는 시스템을 구축하는 데 역할은 매우 중요하다.<br><br>

- 역할을 설계의 중심 개념으로 보는 <b style="color:orange">역할 모델링(Role Modeling)</b>개념을 제안 했다.<br>
상호 작용하는 객체들의 협력 패턴을 역할들 사이의 협력 패턴으로 추상화함으로써 유연하고 재사용 가능한 시스템을 얻을 수 있는 방법에 관해 잘 설명하고 있다.<br>
  역할 모델링 기법은 후에 UML 에 큰 영향을 미치기도 했으며 최근의 객체지향 언어와 설계 기법들은 역할을 중요한 구성 요소로 간주하기 시작했다.<br><br>
  중요한 것은 협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용 가능해진다는 것이다.<br>
  따라서 역할의 가장 큰 장점은 설계의 구성 요소를 추상화할 수 있다는 것이다. <Br>
  
###  역할과 추상화
- 추상화를 이용한 설꼐가 가질 수 있는 두가지 장점
  1. 추상화 계층만을 이용하면 중요한 정책을 상위 수준에서 단순화할 수 있다는 것.
  2. 장점은 설계가 좀 더 유연해진다.<br><br>
  역할은 공통의 책임을 바탕으로 객체의 종류를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화로 볼 수 있다.<Br>
     따라서 추상화가 가지는 두 가지 장점은 협력의 관점에서 역할에도 동일하게 적용될 수 있다.<br><br>
     
- 추상화의 첫번째 장점은 세부 사항에 억눌리지 않고 상위 수준의 정책을 쉽고 간다하게 표현할 수 있다. <br>
- 추상화를 적절하게 사용한다면 불필요한 세부 사항을 생략하고 핵심적인 개념을 강조할 수 있다.<br>
