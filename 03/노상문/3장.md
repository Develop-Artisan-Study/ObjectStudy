#Chapter 3 역할,책임, 협력
## 2장 요약
- 클래스, 추상 클래스, 인터페이스를 조합해서 객체지향 프로그램을 구조화하는 기본적인 방법과 상속을 이용해 다형성을 구현하는 기법.
- 다형성이 지연 바인딩이라는 메커니즘을 통해 구현된다는 사실 설명.
- 상속은 코드를 재사용할 수 있는 가장 널리 알려진 방법이지만 캡슐화의 측면에서 합성이 더 좋은 방법이라는 사실.
- 유연한 객체지향 프로그램은 컴파일 시간 의존성과 실행 시간 의존성이 달라야한다는 것.<br><br>

- 객체지향 패러다임의 관점에서 핵심은 역할(role), 책임(responsibility),협력(collaboration)이다.<br>
클래스,상속 지연 바인딩이 중요하지 않다기보단 다분히 구현 측면에 치우쳐 있다.<br><br>
  
- 객체지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이다. <br>
객체지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다.<bR>
  클래스와 상속은 객체들의 책임과 협력이 어느 정도 자리를 잡은 후에 사용할 수 있는 구현 메커니즘일 뿐이다.<br><bR>
  어플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 <br>
  너무 이른 시기에 구현에 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.<br><br>
  역할,책임,협력이 객체지향에서 가장 중요하며, <br>
  이들이 제자리를 찾지 못한 상태라면 응집도 높은 클래스와 중복 없는 상속 계층을 구현한다고 하더라도 어플리케이션이 잘못된 방향으로 갈 수 있다.<br>
  

## 협력
### 영화 예매 시스템 돌아보기
- 사용자가 영화 예매 시스템을 통해 영화를 예매할 수 있게 하려면 다양한 객체들이 참여하는 협력을 구축해야 한다.<br>
- 객체지향 원칙을 따르는 애플리케이션의 제어 흐름은 어떤 하나의 객체에 의해 통제되지 않고 다양한 객체들 사이에 균형 있게 분배되는 것이 일반적이다.
-객체들은 요청의 흐름을 따라 자신에게 분배된 로직을 실행하면서 어플리케이션의 전체 기능을 완성한다.<br><br>
  
- 다양한 객체들이 영화 예매라는 기능을 구현하기 위해 메시지를 주고 받으면서 상호작용하는 것을 보았을 것이다.<bR>
이처럼 객체들이 어플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 <b style="color:orange">협력</b>이라고 한다.<br><br>
- 객체가 협력에 참여하기 위해 수행하는 로직은 <b style="color:yellow">책임</b>이라고 부른다.<br><br>
- 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수해하는 <b style="color:green">역할</b>을 구성한다.
<br><br>
  
### 협력
- 객체지향 시스템은 자율적인 객체들의 공동체다.<br>
- 객체는 고립된 존재가 아니라 시스템의 기능이라는 더 큰 목표를 달성하기 위해 다른 객체와협력하는 사회적인 존재다.
- 협력은 객체지향의 세계에서 기능을 구현할 수 있는 유일한 방법이다.<br>
- 두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작된다. <br>
- <b style="color:yellow">메시지 전송(message sending)</b>은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이다.<br>
 객체는 다른 객체의 상세한 내부 구현에 직접 접근할 수 없기 때문에 오직 메시지 전송을 통해서만 자신의 요청을 전달할 수 있다.<br><br>
  
> 협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다. 한 객체는 어떤 것이 필요할 때 다른 객체에게 전적으로 위임하거나 서로 협력한다.<br>
> 즉 두 객체가 상호 작용을 통해 더 큰 책임을 수행하는 것이다.<br> 
> 객체 사이의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다.

- 메시지를 수신한 객체는 <b style="color:yellow">메서드</b>를 싱행해 요청에 응답한다.<br>
여기서 객체가 메시지를 처리할 방법을 스스로 선택한다는 점이 중요하다. <br>
  외부의 객체는 오직 메세지만 전송할 수 있을 뿐이며 메시지를 어떻게 처리할지는 메시지를 수신한 객체가 직접 결정한다.<Br>
  이것은 객체가 자신의 일을 스스로 처리할 수 있는 자율적인 존재라는 것을 의미한다.<br><br>
  예를 들어, `Screening`과 `Movie`의 협력 관계를 보면 `Screening`은 `Movie`에 `calculateMovieFee` 메시지를 전송함으로써 예매자 한 명의 요금 계산을 요청한다.<br>
  `Screening`이 `Movie`에게 처리를 위임하는 이유는 요금을 계산하는 데 필요한 기본 요금과 할인 정책을 가장 잘 알고 있는 객체가 `Movie`이기 때문이다.<br>
  요금을 계산하는 작업을 `Screening`이 수행한다면 `Movie`의 인스턴스 변수인 `fee`와 `discountPolicy`에 직접 접근해야만 할 것이다.<br>
  이 경우 `Screening`은 `Movie`의 내부 구현에 결합된다.<br><br>
  이렇게 되면 가장 큰 문제점은 `Movie`의 자율성 훼손이다.<br>
  자율적인 객체란 자신의 상태를 직접 관리하고 스스로의 결정에 따라 행동하는 객체다.<br>
  객체의 자율성을 보장하기 위해서는 필요한 정보와 정보에 기반한 행동을 같은 객체 안에 모아놓아야 한다.<br>
  하지만 `Screening`이 `Movie`의 정보를 이용해 요금을 계싼할 경우 정보와 행동이 `Movie`와 `Screening`이 라는 별도의 객체로 나뉜다.<Br>
  결과적으로 `Movie`는 자율적인 존재가 아니라 수동적인 존재로 변질된다. <br><br>
  `Movie`가 자율적인 존재가 되려면 자신이 알고 있는 정보를 이용해서 스스로 요금을 계산해야 한다.<br>
  이것이 `Screening`이 `Movie`에게 요금을 계산하도록 위임하는 이유다.<br>
  자신이 할수 없는일을 다른 객체에 위임하면 협력에 참여하는 객체들의 전체적인 자율성을 향상 시킬 있다.<br><br>
  결과적으로 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 <b style="color:yellow">캡슐화</b> 하는 것이다.<Br>
  캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있기 때문에 자율적인 객체는 변경하기도 쉬워진다.<br>
  `Screening`이 요금을 계산하기 위해 `Movie`의 내부 구현에 직접 접근한다는 것은 캡슐화의 원칙을 위반한다.<br>
  이 경우 `Movie`의 내부 구현을 바꾸면 `Screening`도 영향을 받게 된다.<br>
  반면 `Movie`가 자신의 정보를 바탕으로 요금을 직접 계산하면 `Screening`과 `Movie`사이의 결합도를 느슨하게 유지할 수 있으며, <br>
  `Movie`에 대한 변경의 여파가 `Screening` 쪽으로 확산되는 것을 막을 수 있다. <br><br>
  정리하자면 자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부 도움이 필요한 경우 적절한 객체에게 메시지를 전송해서 협력을 요청한다.<br>
  메시지를 수신한 객체 역시 메시지를 처리하던 중에 직접 처리할 수 없는 정보나 행동이 필요한 경우 또 다른 객체에게 도움을 요청한다.<Br>
  이처럼 객체들 사이의 협력을 구성하는 일련의 요청과 응답의 흐름을 통해 어플리케이션의 기능이 구현된다.
  
### 협력이 설계를 위한 문맥을 결정한다.<br>
- 객체란 상태와 행동을 함계 캡슐화하는 실행 단위다.<bR>
그렇다면 객체가 가질 수 있는 상태와 행동을 어떤 기준으로 결정해야 할까?<br>
  객체를 설계할 때 어떤 행동과 상태를 할당했다면 그 이유는?<br><br>
  
- 어떤 객체도 섬이 아니다. [Beck]<br>
어플리케이션 안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다.<br>
  그 객체가 어떤 협력에 참여하고 있기 때문이다.<br>
  그리고 객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 보유하고 있기 때문이다.<br><br>
  결론적으로 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.<bR>
  협력이 바뀌면 객체가 제공해야하는 행동 역시 바뀌어야 한다.<br>
  협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공한다.<br><br>
  `Movie`객체는 어떤 행동을 수행할 수 있어야할까? <br>
  영화라는 단어를 들었을 때 대부분의 사람들은 극장에서 영화를 상영하는 장면을 상상할 것이고 자연스럽게 `Movie`객체가 `play` 라는 행동을 수행할 것이라고 생각한다.<br>
  그러나 영화 예매 시스템 안의 `Movie`는 영화를 상영하기 위한 어떤 코드도 포함되어 있지않다.<br>
  `Movie` 에 포함된 대부분의 메서드는 요금을 계산하는 행동과 관련되어 있다.<br>
  이것은 `Movie`가 영화를 예매하기 위한 협력에 참여하고 있고 그 안에서는 요금을 꼐산하는 책임을 지고 있기 때문이다.<br><br>
  
`Movie`의 행동을 결정하는 것은 영화 예매를 위한 협력이다.<br>
협력이라는 문맥을 고려하지 않고 `Movie`의 행동을 결정하는 것은 아무런 의미가 없다.<br>
협력이 존재하기 때문에 객체가 존재하는 것이다.<br><br>
객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.<br>
객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정된다.<br>
객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문에 객체가 수행하는 행동에 필요한 상태도 함께 가지고 있어야 한다.<br><br>

`Movie`가 기본 요금인 `fee`와 할인 정책인 `discountPolicy`라는 인스턴스 변수를 상태의 일부로 포함하는 이유는 요금 계산이라는 행동을 수행하는 데 이 정보들이 필요하기 때문이다.<br><br>

```java
public class Movie{
    private Money fee;
    private DiscountPolicy discountPolicy;
    
    public Money calculateMovieFee(Screening screening){
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

상태는 객체가 행동하는데 필요한 정보에 의해 결정되고 행동은 협력 안에서 객체가 처리할 메시지로 결정된다.<br>
결과적으로는 객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두를 결정한다.<br>
따라서 협력은 객체를 설계하는 데 필요한 일종의 <b style="color:yellow">문맥(context)</b>을 제공한다.