# 책임 할당하기

> 책임 주도 설계의 핵심은 책임을 결정한 후에 책임을 수행할 객체를 결정하는 것이다.  
> 그리고 협력에 참여하는 객체들의 책임이 어느 정도 정리될 때까지는 객체의 내부 상태에 대해 관심을 가지지 않는 것이다.

### 데이터 중심 설계 -> 책임 중심 설계 전환을 위한 원칙
- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라

### 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다.
- 메시지를 결정한 후에 객체를 선택해야 한다.
- 협력이라는 문맥 안에서 메시지에 집중하는 책임 중심의 설계는 캡슐화의 원리를 지키기가 훨씬 쉬워진다.

## 책임 주도 설계
    - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
    - 시스템 책임을 더 작은 책임으로 분할한다.
    - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
    - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
    - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

## GRASP(General Responsibility Assignment Software Pattern) 패턴
- 도메인 개념에서 출발하기  
- 정보 전문가에게 책임을 할당하라
  - 메시지를 전송할 객체는 무엇을 원하는가?
  - 메시지를 수신할 적합한 객체는 누구인가?
- 높은 응집도와 낮은 결합도
  - 동일한 기능을 수행하더라도 응집도가 높고 결합도가 낮은 설계를 선택한다
- 창조자에게 객체 생성 책임을 할당하라
  - > CREATOR 패턴  
    > 객체 A를 생성해야 할 때 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라
    >- B가 A 객체를 포함하거나 참조한다.
    >- B가 A 객체를 기록한다.
    >- B가 A객체를 긴밀하게 사용한다.
    >- B가 A객체를 초기화하는 데 필요한 데이터를 가지고 있다.(이 경우 B는 A에 대한 정보 전문가다)
  - 이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다.
  
## 구현을 통한 검즘
- 가장 큰 문제점은 변경에 취약한 클래스를 포함하고 있다는 것이다.
- 코드를 통해 변경의 이유를 파악할 수 있는 방법
  - 인스턴스 변수가 초기화되는 시점을 살펴볼 것. 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.
  - 메서드들이 인스턴스 변수를 사용하는 방식을 살펴볼 것. 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다. 반면 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다.
- 여러 개의 독립적인 타입이 하나의 클래스 안에 공존하고 있는 경우 클래스를 분리한다. 다형성을 이용해 클래스를 분리하면 새로운 변화를 다루기 쉽게 확장할 수 있다.
- 변경을 캡슐화하도록 책임을 할당하는 것을 GRASP에서는 Protected Variations(변경 보호) 패턴이라고 부른다.

## 변경과 유연성
> 설계를 주도하는 것은 변경이다.
- 상속 대신 합성을 사용하면 설계를 유연하게 변경시킬 수 있다.

## 책임 주도 설계의 대안
- 책임과 객체 사이에서 방황할 때 돌파구를 찾기 위해 선택하는 방법은 최대한 빠르게 목적한 기능을 수행하는 코드를 작성하는 것. 그 후에 **리팩터링 하는 것.**
- 리팩터링
  - 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것
### 메서드 응집도
- 긴 메서드는 응집도가 낮기 때문에 이해하기도 어렵고 재사용하기도 어려우며 변경하기도 어렵다. 이러한 메서드를 몬스터 메서드라고도 부른다.
- 메서드가 명령문들의 그룹으로 구성되고 각 그룹에 주석을 달아야 할 필요가 있다면 그 메서드의 응집도는 낮은 것이다. 주석을 추가하는 대신 메서드를 작게 분해해서 각 메서드의 응집도를 높여라.  
  일단 메서드를 분리하고 나면 public 메서드는 상위 수준의 명세를 읽는 것 같은 느낌이 된다.

### 객체를 자율적으로 만들자
- 자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 메서드를 이동시키면 자율적인 객체가 된다.
- 자율적인 객체는 캡슐화 된다.