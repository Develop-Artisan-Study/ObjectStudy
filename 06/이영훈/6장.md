# 메시지와 인터페이스

> 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 기억하라.

### 클라이언트-서버 모델
- 협력 안에서 메시지를 전송하는 객체를 클라이언트, 수신하는 객체를 서버라고 부른다

### 메시지와 메시지 전송
- 메시지 전송, 메시지 패싱 : 한 객체가 다른 객체에게 도움을 요청하는 것
- 메시지 전송자 : 메시지를 전송하는 객체
- 메시지 수신자 : 메시지를 수신하는 객체
- 메시지는 오퍼레이션명과 인자로 구성됨
- 메시지 전송은 메시지 수신자+오퍼레이션명+인자

### 메시지와 메서드
- 메서드 : 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저
- 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다(다형성).

### 퍼블릭 인터페이스와 오퍼레이션
- 퍼블릭 인터페이스 : 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
- 오퍼레이션 : 퍼블릭 인터페이스에 포함된 메시지
- 퍼블릭 인터페이스 관점에서 보면 '메서드 호출'보다는 '오퍼레이션 호출'이라는 용어를 사용하는 것이 더 적정하다.

### 시그니처
- 시그니처 : 오퍼레이션이나 메서드의 이름과 파라미터 목록을 합쳐 부르는 것
- 오퍼레이션 관점에서 다형성이란 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것

## 인터페이스와 설계 품질
좋은 인터페이스는 **최소한의 인터페이스**와 **추상적인 인터페이스** 둘을 만족하는 인터페이스  
이를 만족시키는 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것

### 디미터 법칙
객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것  
> 오직 하나의 도트(.)만 사용하라

클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍해야 한다  

    - this 객체
    - 메서드의 매개변수
    - this의 속성
    - this의 속성인 컬렉션의 요소
    - 메서드 내에서 생성된 지역 객체

> 디미터 법칙을 따르면 부끄럼 타는 코드(shy code)를 작성할 수 있다.

- 부끄럼 타는 코드 : 불필요한 어떤 것도 다른 객체에게 보여주지 않으며 다른 객체의 구현에 의존하지 않는 코드
- 디미터 법칙은 캡슐화를 다른 관점에서 표현한 것
- 기차 충돌(train wreck) : 메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송하는 것  
  ex) screening.getMovie().getDiscountConditions();
- 무비판적으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질수도 있다.

### 묻지 말고 시켜라(Tell, Don't Ask)
- 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 수신자의 상태를 바꿔서는 안 된다.
 
### 의도를 드러내는 인터페이스
메서드를 명명하는 두 가지 방법
- 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름을 짓는 것
  - 메서드에 대해 제대로 커뮤니케이션하지 못한다
  - 메서드 수준에서 캡슐화를 위반한다
- '어떻게' 가 아니라 '무엇'을 하는지 드러내도록 이름을 짓는 것
  - 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다.

## 원칙의 함정
> 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하라.

### 디미터 법칙은 하나의 도트를 강제하는 규칙이 아니다
- 디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.
- 기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 디미터 법칙을 준수한 것이다.

### 결합도와 응집도의 충돌
- 모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다.  
  결과적으로 객체는 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 응집도가 낮아진다.
- 클래스는 하나의 변경 원인만을 가져야 한다. 디미터 법칙과 묻지 말고 시켜라 원칙을 무작정 따르면 애플리케이션은 응집도가 낮은 객체로 넘쳐나게 된다.
- 디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료 구조인지에 달려있다  
  자료 구조라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.
> 원칙을 맹신하지 마라. 원칙이 적절한 상황과 부적절한 상황을 판단할 수 있는 안목을 길러라. 설계는 트레이드 오프의 산물이다. 소프트웨어 설계에 존재하는 몇 안되는 법칙 중 하나는 "경우에 따라 다르다" 라는 사실을 명심하라.

## 명령-쿼리 분리 원칙
- 루틴(routine) : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
- 프로시저(procedure) : 정해진 절차에 따라 **내부의 상태를 변경하는** 루틴의 한 종류
- 함수(function) : 어떤 절차에 따라 **필요한 값을 계산해서 반환하는** 루틴의 한 종류  
  
    - 프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
    - 함수는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.

- 명령(Command) : 객체의 상태를 수정하는 오퍼레이션
- 쿼리(Query) : 객체와 관련된 정보를 반환하는 오퍼레이션

명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것
> "질문이 답변을 수정해서는 안 된다"

### 명령-쿼리 분리와 참조 투명성
- 참조 투명성 : 어떤 표션식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성  

    e+1 = 2  
    e*2 = 2  

    일 때, 만족한는 e는 1이므로 e를 모두 1로 교체하면  
    1+1 = 2  
    1*2 = 2  
    이런 경우 참조 투명성을 만족한다.  
    수학은 참조 투명성을 엄격하게 준수하는 가장 유명한 체계이다.
- 불변성(immutability) : 하나로 정해진 어떤 값이 변하지 않는 성질
- 참조 투명성을 만족하면 부수 효과(side effect)가 생기지 않는다.
- 명령-쿼리 분리 원칙을 사용하면 객체지향을 제한적으로나마 참조 투명성을 만족하게 만들 수 있다.