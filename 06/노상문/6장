# 6장
## 메시지와 인터페이스
- 중요한 것은 책임이 객체가 수신할 수 있는 메시지의 기반이 된다는 것.
- 어플리케이션은 클래스로 구성되지만 메시지를 통해 정의 된다.

## 협력과 메시지
### 클라이언트- 서버 모델
- 두 객체 사이의 협력 관계를 섦녕하기 위해 사용하는 전통적인 메타포는 <b style="color:orange"> 클라이언트-서버 모델</b>이다.<br>
  - 협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라고 부른다.<bR>
  - 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호 작용이다.
  - 협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성된다.
      1. 객체가 수신하는 메시지의 집합.
      2. 외부의 객체에게 전송하는 메세지의 집합.<bR><br>
    대부분의 사람들은 객체가 수신하는 메시지의 집합에만 초점을 맞추지만 협력에 적합한 객체를 설계하기 위해서는 외부에 전송하는 메시지의 집합도 함께 고려하는 것이 바람직하다.<br><br>
         요점은 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다. <br><br>
         이를 가능하게 하는 것이 메시지다.
         
         
- 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다는 것.
- 두 객체 사이의 협력을 가능하게 해주는 매개체가 바로 메시지라는 것이다.<br>

### 매시지와 메시지 전송
- 한 객체가 다른 객체에게 도움을 요청하는 것을 <b style="color:orange">메시지 전송</b> 또는 <b style="color:yellow">메시지 패싱</b>이라고 부른다.<br>
이때 메시지를 전송하는 객체를 <b style="color:green">메시지 전송자</b> 라고 부르고 메시지를 수신하는 개체를 <b style="color:red">메시지 수신자</b>라고 부른다.<br>
  
- 클라이언트-서버 모델 관점에서는 메시지 전송자는 클라이언트, 메시지 수신자는 서버라고 부르기도 한다.<br><br>
- 메시지는 <b style="color:orange">오퍼레이션명과 인자</b>로 구성되며 메시지 전송은 여기에 <b style="color:orange">메시지 수신자</b>를 추가한 것이다.<br>
따라서 메시지 전송은 <b style="color:orange">메시지 수신자, 오퍼레이션, 인자 </b>의 조합이다.<br><bR>
  
### 메시지와 메서드
- 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려 있다.<bR><br>
- 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.<br>
- 코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다.<br>
- 기술적인 관점에서 객체 사이의 메시지 전송은 전통적인 방식의 함수 호출, 프로시저 호출과는 다르다.<br>
전통적인 방식의 개발자는 어떤 코드가 실행될지를 정확하게 알고 있는 상황에서 함수 호출이나 프로시저 호출 구문을 작성한다.<br>
  코드의 의미가 컴파일 시점과 실행 시점에 동일하다는 것이다.<br><br>
  객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실햄 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.<br><br>
  
- 메시지 전송을 코드 사엥 표기하는 시점에는 어떤 코드가 실행될 것인지를 정확하게 알 수 없다.<br>
실행 시점에 실제로 실행되는 코드는 메시지를 수신하는 객체의 타입에 따라 달라지기 때문에 우리는 그저 메시지에 응답할 수 있는 객체가 존재하고 그 객체가 적절한 메서드를 선택해서 응답할 것이라고 믿을 수 밖에 없다.
- 메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다.<br>
- 메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 된다.<br>
- 수신자가 어떤 클래스의 인스턴스인지, 어떤 방식으로 요청을 처리하는지 모르더라도 원활한 협력이 가능하다.<br>
- 메시지 수신자 역시 누가 메시지를 전송하는 알 필요 없이 단지 메시지가 도착했다라는 사실만 알면 된다.<br>
메시지 수신자는 메시지를 처리하기 위해 필요한 메서드를 스스로 결정할 수 있는 자율권을 누린다.<br><br>
  - 메시지 전송자와 수신자는 서로에 대한 상세한 정보를 알지 못한 채 메시지에만 연결된다.<Br>
    실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 된다.<br><br>
    
### 퍼블릭 인터페이스와 오퍼레이션
- 외부의 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다.<br>
객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 <b style="color:orange">퍼블릭 인터페이스</b> 라고 부른다.<br><br>
- 퍼블릭 인터페이스에 포함된 메시지를 <b style="color:orange">오퍼레이션</b> 이라고 부른다.<br>
- 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다.<br>
흔히 오퍼레이션이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다.<Br>
- 메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다.<Br>
- UML : 오퍼레이션이란 실행하기 위해 객체가 호출될 수 있는 변환이나 정의에 관한 명세다.<br>
인터페이스의 각 요소는 오퍼레이션이다. 오퍼레이션은 구현이 아닌 추상화다.<br>
  메서드는 오퍼레이션을 구현한 것이다.<br>메서드는 오퍼레이션에 대한 구현이다.<br>
  메서드는 오퍼레이션과 연관된 알고리즘 또는 절차를 명시한다.
- 프로그래밍 언어의 관점에서 객체가 다른 객체에게 메시지를 전송하면 런타임 시스템은 메시지 전송을 오퍼리에션 호출로 해석하고 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행한다.<br>
따라서 퍼블릭 인터페이스와 메시지의 관점을 보면 '메서드 호출'보다는 '오퍼레이션 호출'이라는 용어를 사용하는 것이 더 적절하다.<br>
  
### 시그니처
- 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 <b style="color:orange">시그니쳐</b>라고 부른다.<br>
- 오퍼레이션은 실행코드 없이 시그니처만을 정의한 것이다.<br>
- 메서드는 이 시그니처에 구현을 더한 것이다.<Br>
일반적으로 메시지를 수신하면 오퍼레이션의 시그니처와 동일한 메서드가 실행 된다.<br><br>
  하나의 오퍼레이션에 대해 오직 하나의 메서드만 존재하는 경우엔 오퍼레이션과 메서드를 구분할 필요가 없다.
- 다형성의 사용을 위해서는 오퍼레이션에 대해 다양한 메서드를 구현해야하만 한다.<br>
따라서 오퍼레이션의 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것이라고 정의할 수 있다.<br>
  
## 인터페이스와 설계 품질
- 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 한다.<br>
최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다.<br>
  추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다.<br><br>
  
- 최소주의를 따르면서도 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것이다.<br>
책임 주도 설계 방법은 메시지를 먼저 선택함으로써 협려과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지한다.<br>
  따라서 인터페이스는 최소의 오퍼레이션만 포함하게 된다.<br>
  
- 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택함으로써 클라이언트의 의도를 메시지에 표현할수 있게 된다.<br>
- 퍼블릭 인터페이스의 품질에 영향을 미치는 다음과 같은 원칙과 기법에 대해서다.
  - 디미터 법칙
  - 묻지 말고 시켜라.
  - 의도를 드러내는 인터페이스
  - 명령 -쿼리 분리
    
### 디미터의 법칙
- 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 바로 <b style="color:orange"> 디미터 법칙이다.</b>
- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 것이다.<br>
"낯선 자에게 말하지 말라 "  "오직 인접한 이웃하고만 말하라"로 요약가능
  
- 디미터 법칙을 따르기 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍해야한다.<br>
모든 클래스 C 와 C에 구현된 모든 메서드 M에 대해서, M이 메시지를 전송할 수있는 모든 객체는 다음에 서술된 클래스의 인스턴스여야 한다.<br>
  이때 M에 의해 생성된 객체나 M이 호출하는 메서드에 의해 생성된 객체, 전역 변수로 선언된 객체는 모두 M 의 인자로 간주한다.
  - M 의 인자로 전달된 클래스( C자체를 포함)
  - C 의 인스턴스 변수의 클래스
    
 클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍해야 한다고 이해해도 무방.
  - this 객체
  - 메서드의 매개변수
  - this의 속성
  - this의 속성인 컬렉션 요소
  - 메서드 내에서 생성된 지역 객체

- 디미터 법칙을 따르면 부끄럼타는 코드를 작성할 수 있다.<br>
불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다.<br>
  디미터 법칙을 따르는 코드는 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다. 클라이어늩와 서버 사이에 낮은 결합도를 유지할 수 있다.<br><br>
  
- 디미터 법칙과 캡슐화
  - 디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다.<br>
    디미터 법칙이 가치 있는 이유는 클래스를 캡슐화 하기 위해 따라야 하는 구체적인 지침을 제공하기 때문이다.<br>
    캡슐화 원칙이 클래스 내부의 구현을 감춰야 한다는 사실을 강조한다면<br>
    디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야하는 요소를 제한 한다.<br>
    디미터 법칙은 협려과 구현이라는 사뭇 달라보이는 두 가지 문맥을 하나의 유기적인 개념으로 통합한다.<Br>
    클래스 내부 구현을 채워가는 동시에 현재 협력하고 있는 클래스에 관해서도 고민하도록 주의를 환기 시키기 때문이다.<br><br>
    
- 기차충돌 :  메시지 전송자가 수신자 내부 구조에 대해 물어보고 변환받은 요소에 대해 연쇄적으로 메시지를 전송한다.<br>
클래스 내부 구현이 외부로 노출됐을때 나타는 전형적인 형태로 메시지 전송자는 수신자의 내부 정보를 자세히 알게 된다.<br>이는 캡슐화의 실패, 수신자 내부 구현에 강하게 결합된다.<br>
  
### 묻지 말고 시켜라
- 디미터 법칙은 휼륭한 메시지는 객체의 상태에 관해 묻지말고 원하는 것을 시켜야 한다는 사실을 강조한다.<br>
- 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.<br>
- 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.<br>
묻지 말고 시켜라 원칙에 따르도록 메시지를 결정하다보면 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 갖는 클래스를 얻게 된다.<bR>
  
### 의도를 드러내는 인터페이스
- 메서드의 이름을 짓는 방법은 어떻게가 아니라 무엇을 하는지를 드러내는 것이다.<br>
- 어떻게 수행하는지를 드러내는 이름이란 메서드의 내부 구현을 설명하는 이름이다.<br>
결과적으로 협력을 설꼐하기 시작하는 이른시기부터 클래스 내부 구현에 관해 고민할수 밖에 없다.<br>
  반면 무엇을 하는지를 드러내도록 메서드의 이름을 짓기 위해서는 객체가 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다.<br>
  이것은 외부의 객체가 메시지를 전송하는 목적을 먼저 생가하도록 만들며, 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 된다.<br>
- 메서드가 어떻게 수행하느냐가 아닌 무엇을 하느냐에 초점을 맞추면 클라이언트의 관점에서 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커지고 결과 다양한 타입의 객체가 참여할 수 있는 유여한 협력을 얻게 된다.<br>

- 어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드 이름을 짓는 패턴을 <b style="color:orange">의도를 드러내는 선택자</b>라고 부른다.

- <b style="color:orange">의도를 드러내는 선택자</b>를 인터페이스 레벨로 확장한 의도를 드러내는 인터페이스를 제시했다.<br>
의도를 드러내는 인터페이스를 한 마디로 요약하면 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련되 의도만을 표현해야 한다는 것이다.
  

### 함께 모으기
- 디미터 법칙을 위반하는 설계는 인터페이스와 구현의 분리 원칙을 위반한다.<Br>
- 디미터 법칙은 객체 간의 협력을 설계할 때 캡슐화를 위반하는 메시지가 인터페이스에 포함되지 않도록 제한한다.
- 묻지 말고 시켜라 원칙은 디미터의 법칙을 준수하는 협력을 만들기 위한 스타일을 제시한다.<br>
- 의도를 드러내는 인터페이스 원칙은 객체의 퍼블릭 인터페이스에 어떤 이름이 드러나야하는지에 대한 지침을 제공함으로써 코드의 목적을 명확하게 소통하게 해준다.<br>


## 원칙의 함정

### 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.<br>
- 디미터 법칙은 하나의 도트만을 사용하라 라는 말로 요약이 되기도 하지만.
- 디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 위부로 노출되는 경우로 한정된다.<Br>
- 하나 이상의 도트를 사용하는 것은 모든 케이스가 디미터 법칙 위반인 것은 아니다.<br>
기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한다.
  
### 결합도와 응집도의 충돌
- 위임 메서드를 통해 객체의 내부 구조를 감추는 것은 협력에 참여하는 객체들의 결합도를 낮출 수 있는 동시에 객체의 응집도를 높일 수 있는 가장 효과적인 방법이다.<br><br>
- 묻지말고 시켜라와 디미터 법칙을 준수하는 것이 항상 긍정적인 결과만 만들진 않는다.
- 클래스는 하나의 변경 원인만을 가져야 한다.<br>
서로 상관없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮으며 작은 변경으로도 쉽게 무너질 수 있다.<Br>
  디미터의 법치과 묻지말고 시켜라 원칙을 무작정 따르면 어플리케이션은 응집도가 낮은 객체로 넘쳐날 것이다.<br>
  - 객체는 내부 구조를 숨겨야하므로 디미터 법칙을 따르는 것이 좋지만 자료 구조라면 당연히 내부를 노출해야하므로 디미터 법칙을 적용할 필요가 없다.<br>

## 명령- 쿼리 분리 원칙
- 루틴: 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
- 루틴은 프로시저와 함수로 구분 가능.
  - 프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
  - 함수는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.
    
- 명령과 쿼리는 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또다른 이름이다.<br>
- 쿼리 : 객체와 관련된 정보를 반환하는 오퍼레이션
- 명령 : 객체의 상태를 수정하는 오퍼레이션 
  - 명령은 프로시저와 동일/ 쿼리는 함수와 동일하다.
    
- 명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명려이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다.<br>
어던 오퍼레이션도 명령인 동시에 쿼리여서도 안된다.<br>
  - 객체의 상태를 변경하는 명령은 반환값을 가질수 없다.
  - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
    
- 명령- 쿼리 분리에 원칙에 따라 작성된 객체의 인터페이스를 명령- 쿼리 인터페이스 라고 부른다.<br>

### 반복 일정의 명령과 쿼리 분리하기
- 이벤트 : 특정 일자에 실제로 발생하는 사건을 의미
- 반복일정: 일주일 단위로 돌아오는 특정 시간 간격에 발생하하는 시건 전체를 포괄적으로 지칭하는 용어



### 명령-쿼리 분리와 참조 투명성
- 버그가 적고 디버깅이 용이하고 쿼리의 순서에 따라 실행결과가 변하지 않는 코드를 작성할 수 있다.
- 참조 투명성 : 어떤 표현식 e가 있을때 e의 값으로 e가 나타내는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성을 의미

### 책임에 초점을 맞춰라
- 디미터의 법칙: 협력이라는 컨텍스트 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다.<br>
 수신할 객체를 알지 못한 상태에서 메시지를 먼저 선택하기 때문에 객체의 내부 구조에 대해 고민할 필요가 없어진다.
  따라서 메시지가 객체를 선택하게 함으로써 의도적으로 디미터 법칙을 위반할 위험을 최소화할 수 있다.
  
- 묻지 말고 시켜라 : 메시지를 먼저 선택하면 묻지말고 시켜라 스타일에 따라 협력을 구조화 하게 된다.<br>
클라이언트의 관점에서 메시지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메시지를 전송하면된다.<br>
  
- 의도를 드러내는 인터페이스 : 메시지를 먼저 선택한다는 것은 메시지를 전송하는 클라이언트의 관점에서 메시지의 이름을 정한다는 것이다.<br>
당연히 그이름에는 클라이언트가 무엇을 원하는지 그 의도가 분명하게 드러날 수 밖에 없다.<br><br>
  
- 명령 - 쿼리 분리 원칙 : 메시지를 먼저 선택한다는 것은 협력이라는 문맥 안에서 객체의 인터페이스에 관해 고민한다는 것을 의미.<br>
객체가 단순히 어떤 일을 해야하는지 뿐만 아니라 협력속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게 된다.<br>
  따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.<br>
  
- 계약에 의한 설계 : 협력을 위해 클라이어트와 서버가 준수해야하는 제약을 코드상에 명시적으로 표현하고 강제할 수 있는 방법이다.<br>

