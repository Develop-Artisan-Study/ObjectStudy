# 서브클래싱과 서브타이핑
- 상속의 두 가지 용도
  - 타입 계층의 구현
  - 코드 재사용
  
상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이여야 한다.  
타입 사이의 관계를 고려하지 않은 채 단순히 코드를 재사용하기 위해 상속을 사용해서는 안 된다.  

## 타입
### 개념 관점의 타입
개념 관점의 타입이란 우리가 인지하는 세상의 사물의 종류이다.
- 인스턴스  
  어떤 대상이 타입으로 분류될 때 그 대상을 지칭
   
- 타입을 구성하는 세 가지 요소
  - 심볼(symbol) : 타입에 이름을 붙인 것
  - 내연(intrension) : 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동
  - 외연(extension) : 타입에 속하는 객체들의 집합

### 프로그래밍 언어 관점의 타입
프로그래밍 언어에서 타입은 두 가지 목적을 위해 사용된다.
- 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다
- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다

### 객체지향 패러다임 관점의 타입
객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다.
> 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.

## 타입 계층
### 타입 사이의 포함관계
타입 계층을 구성하는 두 타입 간의 관계에서
- 슈퍼타입(supertype) : 더 일반적인 타입
- 서브타입(subtype) : 더 특수한 타입
   
내연과 외연 관점에서 서브타입과 슈퍼타입을 다음과 같이 정의할 수 있다
- 슈퍼타입은 다음과 같은 특징을 가지는 타입을 가리킨다
  - 집합이 다른 집합의 모든 멤버를 포함한다
  - 타입 정의가 다른 타입보다 좀 더 일반적이다
- 서브타입은 다음과 같은 특징을 가지는 타입을 가리킨다
  - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다
  - 타입 정의가 다른 타입보다 좀 더 구체적이다

### 객체지향 프로그래밍과 타입 계층
퍼블릭 인터페이스 관점에서 슈퍼타입과 서브타입을 다음과 같이 정의할 수 있다.
- 슈퍼타입이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것이다
- 서브타입이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것이다

## 서브클래싱과 서브타이핑
상속을 이용해 타입 계층을 구현한다는 것은 부모 클래스가 슈퍼타입의 역할을, 자식 클래스가 서브타입의 역할을 수행하도록 클래스 사이의 관계를 정의한다는 것을 의미한다.

### 언제 상속을 사용해야 하는가?
상속의 올바른 용도는 타입 계층을 구현하는 것이다.  
마틴 오더스키는 다음과 같은 질문을 해보고 두 질문 모두 '예'라고 답할 수 있는 경우에만 상속을 사용하라고 조언한다.
- 상속 관계가 is-a 관계를 모델링하는가?
- 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?

설계 관점에서 상속을 적용할지 여부를 결정하기 위해 첫 번째 질문보다는 두 번째 질문에 초점을 맞추는 것이 중요하다.

### is-a 관계
어떤 타입 S가 다른 타입 T의 일종이라면 당연히 "타입 S는 타입 T다(S is-a T)"라고 말할 수 있어야 한다.  
   
어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다.  
슈퍼타입과 서브타입 관계에서는 is-a보다 행동 호환성이 더 중요하다.

### 행동 호환성
중요한 것은 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점이라는 것이다.  
   
### 클라이언트의 기대에 따라 계층 분리하기
- 인터페이스 분리 원칙(Interface Segregation Principle, ISP)  
  인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의한 영향을 제어하는 설계 원칙
> 한 가지 주의해야 할 점이 있다. 설계가 꼭 현실세계를 반영할 필요는 없다는 것이다.  
> 현실을 정확하게 묘사하는 것이 아니라 요구사항을 실용적으로 수용하는 것을 목표로 삼아야 한다.

### 서브클래싱과 서브타이핑
- 서브클래싱  
  다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우  
  구현 상속(implementation inheritance) 또는 클래스 상속(class inheritance)이라고 부르기도 한다
- 서브타이핑  
  타입 계층을 구성하기 위해 상속을 사용하는 경우  
  인터페이스 상속(interface inheritance)이라고 부르기도 한다
   
어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행동 호환성(behavioral substitution)을 만족시켜야 한다.  
자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스의 대체 가능성(subsitutability)을 포함한다.

## 리스코프 치환 원칙
상속 관계로 연결한 두 클래스가 서브타이핑 관계를 만족시키기 위해서는 다음의 조건을 만족시켜야 한다.
- S형의 각 개체 o1에 대해 T형의 객체 o2가 하나 있고, T에 의해 정의된 모든 프로그램 P에서 T가 S로 치환될 때, P의 동작이 변하지 않으면 S는 T의 서브타입이다.

한 마디로 정리하면 "서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다"  
클라이언트가 "차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다"
> 리스코프 치환 원칙에 따르면 자식 클래스가 부모 클래스와 행동 호환성을 유지함으로써 부모 클래스를 대체할 수 있도록 구현된 상속 관계만을 서브타이핑이라고 불러야 한다.

### 클라이언트와 대체 가능성
리스코프 치환 원칙은 "클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다"는 아주 중요한 결론을 이끈다.  
어떤 모델의 유효성은 클라이언트의 관점에서만 검증 가능하다는 것이다.

### is-a 관계 다시 살펴보기
슈퍼타입과 서브타입이 클라이언트 입장에서 행동이 호환된다면 두 타입을 is-a로 연결해 문장을 만들어도 어색하지 않은 단어로 타입의 이름을 정하라는 것이다.  
   
결론적으로 상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계다.

### 리스코프 치환 원칙은 유연한 설계의 기반이다
자식 클래스가 클라이언트 관점에서 부모 클래스를 대체할 수 있다면 기능 확장을 위해 자식 클래스를 추가하더라도 코드를 수정할 필요가 없어진다.  
따라서 리스코프 치환 원칙은 개방-폐쇄 원칙을 만족하는 설계를 위한 전제조건이다.  
일반적으로 리스코프 치환 원칙 위반은 잠재적인 개방-폐쇄 원칙 위반이다.

### 타입 계층과 리스코프 치환 원칙
클래스를 이용하지 않더라도 서브타이핑을 구현할 수 있다.  
> 핵심은 구현 방법과 무관하게 클라이언트의 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브타입에게도 적용돼야 한다는 것이다.

## 계약에 의한 설계와 서브타이핑
클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것을 계약에 의한 설계(Design By Contract, DBC) 라고 부른다.
- 계약에 의한 설계의 세 가지 요소
  - 사전조건(precondition)  
    클라이언트가 정살적으로 메서드를 실행하기 위해 만족시켜야 하는 조건
  - 사후조건(postcondition)  
    메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 조건
  - 클래스 불변식(class invariant)  
    메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 공식
   
리스코프 치환 원칙과 계약에 의한 설계 사이의 관계를 다음과 같은 한 문장으로 요약할 수 있다.  
> 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 '계약'을 준수해야 한다.
   
- 사전조건과 사후조건은 assertion으로 표현할 수 있다

### 서브타입과 계약
계약 관점에서 상속이 초래하는 가장 큰 문제는 자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 수 있다는 것이다.  
자식 클래스가 부모 클래스의 서브타입이 되기 위해서는 다음 조건을 만족시켜야 한다.
- 서브타입에 더 강력한 사전조건을 정의할 수 없다.
- 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
- 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
- 서브타입에 더 약한 사후조건을 정의할 수 없다.

