# 서브클래싱과 서브타이핑

- 상속은 두가지 용도로 사용된다
  - 타입 계층의 구현
    - 타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다.
    - 부모 클래스는 자식 클래스의 일반화이고 자식 클래스는 부모 클래스의 특수화이다.
  - 코드 재사용
    - 간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있다.
    - 하지만 부모 클래스와 자식 클래스가 강하게 결합되어 변경하기 어려운 코드를 얻게될 확률이 높다.

## 타입

### 개념 관점의 타입

- 개념 관점에서 타입이란 우리가 인지하는 세상의 사물의 종류를 의미한다.
- 타입은 심볼, 내연, 외연의 세 가지 요소로 구성된다.
  - 심볼
    - 타입에 이름을 붙인 것이다.
  - 내연
    - 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다.
  - 외연
    - 타입에 속하는 객체들의 집합이다.

### 프로그래밍 언어 관점의 타입

- 프로그래밍 언어 관점에서 타입은 연속적인 비트에 의미와 제약을 부여하기 위해 사용된다.
- 프로그래밍 언어에서의 타입은 두 가지 목적을 위해 사용된다.
  - 타입에 수행할 수 있는 유효한 오퍼레이션의 집합을 정의한다.
    - 자바에서 + 연산자는 원시형 숫자 타입이나 문자열 타입의 객체에는 사용할 수 있지만 다른 클래스의 인스턴스에 대해서는 사용할 수 없다.
    - C++이나 C#에서는 연산자 오버로딩을 통해 연산자를 사용하는 것이 가능하다.
    - 모든 객체지향 언어는 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한함으로써 프로그래머의 실수를 막아준다.
  - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.
    - 자바에서 a + b 연산의 경우 int라면 두 수를 더할 것이고 string이면 두 문자열을 합칠 것이다.
    - 이 경우 객체를 생성하는 방법에 대한 문맥을 결정하는 것은 바로 객체의 타입이다.

### 객체지향 패러다임 관점의 타입

- 타입은 다음과 같이 두가지 관점에서 정의할 수 있다.
  - 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류이다.
  - 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합이다.
- 객체지향 프로그래밍에서 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의하는 것이다.
- 객체가 수신할 수 있는 메시지의 집합은 퍼블릭 인터페이스라고 부르고 타입을 정의하는 것은 이를 정의하는 것과 동일하다.
- 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류한다.

## 타입 계층

### 타입 사이의 포함관계

- 수학에서 집합은 다른 집합을 포함할 수 있다.
- 타입 역시 객체들의 집합이기 때문에 다른 타입을 포함하는 것이 가능하다.
- 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 슈퍼타입이라고 부르고 더 특수한 타입을 서브타입이라고 부른다.
- 내연과 외연의 관점에서 보는 일반화와 특수화
  - 내연의 관점
    - 특수한 타입의 정의나 일반적인 타입의 정의를 좀 더 구체화한 것이다.
    - 객체지향 언어의 내연은 컴퓨터에게 특정한 작업을 지시하기 위해 객체를 생성하고 객체 사이의 메시지 전송을 통한 협력관계를 구성할 수 있는 어휘와 문법적 규칙의 집합으로 정의할 수 있다.
  - 외연의 관점
    - 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포함하는 슈퍼셋이다.
    - 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 서브셋이다.
    - 특수한 타입에 속한 인스턴스는 동시에 더 일반적인 타입의 인스턴스이기도 하다.
  - 다음과 같이 일반화와 특수화를 정의할 수 있다.
    - 일반화는 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.
    - 특수화는 다른 타입안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.
  - 서브타입과 슈퍼타입을 다음과 같이 정의할 수 있다.
    - 슈퍼타입은 다음과 같은 특징을 가지는 타입을 가리킨다.
      - 집합이 다른 집합의 모든 멤버를 포함한다.
      - 타입 정의가 다른 타입보다 좀 더 일반적이다.
    - 서브타입은 다음과 같은 특징을 가지는 타입을 가리킨다.
      - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
      - 타입 정의가 다른 타입보다 좀 더 구체적이다.

### 객체지향 프로그래밍과 타입 계층

- 퍼블릭 인터페이스의 관점에서 슈퍼타입과 서브타입을 다음과 같이 정의할 수 있다.
  - 슈퍼타입이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정리한 것이다.
  - 서브타입이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은의미로 정의한 것이다.
- 일반적인 타입과 구체적인 타입 간의 관계를 형성하는 기준이 퍼블릭 인터페이스이다.

## 서브클래싱과 서브타이핑

- 객체지향 프로그래밍 언어에서 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것이다.
- 상속을 이용해 타입 계층을 구현한다는 것은 부모 클래스가 슈퍼타입의 역할을, 자식 클래스가 서브타입의 역할을 수행하도록 클래스 사이의 관계를 정의한다는 것을 의미한다.

### 언제 상속을 사용해야 하는가?

- 상속을 사용해야 할 때
  - 상속 관계가 is-a 관계를 모델링하는가?
    - 애플리케이션을 구성하는 어휘에 대한 우리의 관점에 기반한다.
    - 일반적으로 자식 클래스는 부모 클래스라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.
  - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
    - 상속 게층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다.
    - 이를 자식 클래스와 부모 클래스 사이의 행동 호환성이라고 부른다.

### is-a 관계

- 두 클래스가 어휘적으로 is-a 관계를 모델링할 경우에만 상속을 사용해야 한다.
- 하지만 is-a 관계가 직관적이고 명쾌한 것은 아니다.
  - 펭귄과 새의 관계 (새는 날 수 있지만 펭귄은 아니다.)

### 행동 호환성

- 타입과 이름 사이에 개념적으로 어떤 연고나성이 있다고 하더라도 행동에 연관성이 없다면 is-a 관계를 사용하지 말아야 한다.
- 두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다는 것이다.
- 이를 판단하는 기준은 클라이언트의 관점이다.

### 클라이언트의 기대에 따라 계층 분리하기

- 행동 호환성을 만족시키지 않는 상속 게층을 그대로 유지한 채 클라이언트의 기대를 충족 시킬 수 있는 방법을 찾기란 쉽지않다.
- 문제를 해결할 수 있는 방법은 클라이언트의 기대에 맞게 상속 계층을 분리하는 것 뿐이다.
- 펭귄과 새의 관계
  - 새를 날수 있는 새와 날지 못하는 새로 나눈다.
  - 날지 못하는 새에 펭귄을 포함시킨다.
- 클라이언트에 따라 인터페이스를 분리하면 변경에 대한 영향을 더 세밀하게 제어할 수 있게 된다.
- 이러한 설계 원칙을 인터페이스 분리 원칙이라고 부른다.

### 서브클래싱과 서브타이핑

- 상속을 사용하는 두가지 목적에 이름을 붙였는데 서브클래싱과 서브타이핑이 그것이다.
  - 서브클래싱
    - 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우를 가르킨다.
    - 자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.
    - 서브클래싱을 구현 상속 또는 클래스 상속이라고 부른다.
  - 서브타이핑
    - 타입 계층을 구성하기 위해 상속을 사용하는 경우를 가르킨다.
    - 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.
    - 인터페이스 상속이라고 부른다.
- 슈퍼타입과 서브타입 사이의 관계에서 가장 중요한 것은 퍼블릭 인터페이스이다.
- 서브타이핑 관계가 유지되기 위해서는 서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다.
- 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행동 호환성을 만족시켜야 한다.
- 자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스의 대체 가능성을 포함한다.

## 리스코프 치환 원칙

- 올바른 상속 관계의 특징을 정의하기 위해 리스코프 치환 원칙을 발표했다.
  - 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다.
  - 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.

### 클라이언트와 대체 가능성

- 리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다.
- 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것은 불가능하다.
- 상속 관계에 있는 두 클래스 사이의 관계를 클라이언트와 떨어트려 놓고 판단하면 안된다.
- 대체 가능성을 결정하는 것은 클라이언트다.

### is-a 관계 다시 살펴보기

- 클라이언트 관점에서 자식 클래스의 행동이 부모 클래스의 행동과 호환되지 않고 그로 인해 대체가 불가능하다면 is-a 관계가 아니다.
- is-a 관계는 객체지향에서 중요한 것은 객체의 속성이 아니라 객체의 행동이라는 점을 강조한다.
- 상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계다. 서브클래싱을 구현하기 위해 상속을 사용했다면 is-a 관계라고 말할 수 없다.

### 리스코프 치환 원칙은 유연한 설계의 기반이다.

- 리스코프 치환 원칙은 클라이언트가 어떤 자식 클래스와도 안정적으로 협력할 수 있는 상속 구조를 구현할 수 있는 가이드라인을 제공한다.
- 리스코프 치환 원칙은 개방 폐쇄 원칙을 지원하는데 개방 폐쇄 원칙을 만족하기 위한 전제 조건이며 잠재적인 개방 폐쇄 원칙이다.

## 계약에 의한 설계와 서브타이핑

- 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것을 계약에 의한 설계라고 부른다.
- 계약에 의한 설계는 다음 세 가지 요소로 구성된다.
  - 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 사전조건
  - 메서드가 실행된 후에 서버가 클라이언트에 보장해야 하는 사후조건
  - 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 클래스 불변식
- 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 한다.

### 서브타입과 계약

- 자식 클래스가 부모 클래스의 서브타입이 되기 위해서는 다음 조건을 만족시켜야 한다.

  - 서브타입에 더 강력한 사전조건을 정의할 수 없다.
  - 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
  - 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
  - 서브타입에 더 약한 사후조건을 정의할 수 없다.

- 계약에 의한 설계는 클라이언트 관점에서의 대체 가능성을 계약으로 설명할 수 있다는 사실을 잘 보여준다.

- 상속은 타입 계층을 구현할 수 있는 전통적인 방법이지만 유일한 방법은 아니다.

  

