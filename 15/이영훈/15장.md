# 디자인 패턴과 프레임워크
> 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 **디자인 패턴**이라고 부른다.

디자인 패턴이 설계를 재사용하기 위한 것이라면 프레임워크는 설계와 코드를 함께 재사용하기 위한 것이다.  
결론적으로 디자인 패턴과 프레임워크 모두 협력을 일관성 있게 만들기 위한 방법이다.

## 디자인 패턴과 설계 재사용
### 소프트웨어 패턴
- 패턴의 핵심적인 특징
  - 패턴은 반복적으로 발생하는 문제와 해법의 쌍의로 정의된다.
  - 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다.
  - 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
  - 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.
   
> 패턴 정의는 하나의 실무 컨텍스트(practical context)에서 유용하게 사용해 왔고 다른 실무 컨텍스트에서도 유용할 것이라고 예상되는 아이디어(idea)다.
   
- 3의 규칙(Rule of Three)  
  최소 세 가지의 서로 다른 시스템에 특별한 문제 없이 적용할 수 있고 유용한 경우에만 패턴으로 간주할 수 있다.
   
> 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 **패턴에서 가장 중요한 요소는 패턴의 '이름'이다.**

잘 알려진 이름을 사용함으로써 "인터페이스를 하나 추가하고 이 인터페이스를 구체화하는 클래스를 만든 후 객체의 생성자나 setter에 할당해서 런타임 시에 알고리즘을 바꿀 수 있게 하자" 는 장황한 대화가  
STRATEGY 패턴을 적용하자는 단순한 대화로 바뀐다.  

### 패턴 분류
- 패턴의 분류
  - 디자인 패턴(Design Pattern)  
    특정 정황 내에서 일반적인 설계 문제를 해결하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술하는 것  
    디자인 패턴은 중간 규모의 패턴으로 특정한 설계 문제를 해결하는 것을 목적으로 하며 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.  
  - 아키텍처 패턴(Architecture Pattern)  
    미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의하며, 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.  
    구체적인 소프트웨어 아키텍처를 위한 템플릿을 제공하며 디자인 패턴과 마찬가지로 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.  
  - 이디엄(Idiom)  
    특정 프로그래밍 언어에만 국한된 하위 레벨 패턴으로 주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다.
  - 분석 패턴(Analysis Pattern)  
    도메인 내의 개념적인 문제를 해결하는데 초점을 맞춘 패턴.  
    업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합.  
    단 하나의 도메인에 대해서만 적절할 수도 있고 여러 도메인에 걸쳐 적용할 수도 있다.

### 패턴과 책임-주도 설계
특정한 상황에 적용 가능한 패턴을 잘 알고 있다면 책임 주도 설계의 절차를 하나하나 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손쉽게 구성할 수 있다.  
   
패턴의 구성 요소는 클래스가 아니라 '역할'이다.  
디자인 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다.  

### 캡슐화와 디자인 패턴
몇 가지 이례적인 경우를 제외하면 널리 알려진 대부분의 디자인 패턴은 협력을 일관성 있고 유연하게 만드는 것을 목적으로 한다.  
따라서 각 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의하고 있다.  
   
어떤 디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는 것이 중요하다.  
그리고 각 디자인 패턴이 변경을 캡슐화하기 위해 어떤 방법을 사용하는지 이해하는 것이 더 중요하다.  

### 패턴은 출발점이다
패턴은 설계의 목표가 돼서는 안 된다.  
패턴은 단지 목표로 하는 설계에 이를 수 있는 방향을 제시하는 나침반에 불과하다.  
디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라.  
   
명확한 트레이드오프 없이 패턴을 남용하면 설계가 불필요하게 복잡해지게 된다.  

## 프레임워크와 코드 재사용
### 코드 재사용 대 설계 재사용
가장 이상적인 형태의 재사용 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것이다.  
- 프레임워크  
  추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계  
  애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격
   
프레임워크는 코드를 재사용함으로써 설계 아이디어를 재사용한다.  
프레임워크는 애플리케이션의 아키텍처를 제공하며 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함한다.  
프레임워크는 애플리케이션을 확장할 수 있도록 부분적으로 구현된 추상 클래스와 인터페이스 집합뿐만 아니라 추가적인 작업 없이도 재사용 가능한 다양한 종류의 컴포넌트도 함께 제공한다.  

### 상위 정책과 하위 정책으로 패키지 분리하기
상위 정책이 세부 사항에 비해 재사용될 가능성이 높다.  
요점은 상위 정책이 세부 사항보다 더 다양한 상황에서 재사용될 수 있어야 한다는 것이다.  
   
의존성 역전 원칙의 관점에서 세부 사항은 '변경'을 의미한다.  
프레임워크는 여러 애플리케이션에 걸쳐 재사용 가능해야 하기 때문에 변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할 수 있도록 별도의 '배포 단위'로 분리해야 한다.  
이를 위한 첫걸음은 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리하는 것이다.  

### 제어 역전 원리
의존성 역전 원리는 전통적인 설계 방법과 객체지향을 구분하는 가장 핵심적인 원리다.  
로버트 마틴은 훌륭한 객체지향 설계는 의존성이 역전된 설계라는 점을 강조한다.  

> 프로그램의 의존성이 역전돼 있다면, 이것은 객체지향 설계를 갖는 것이다.  
> 그 의존성이 역전돼 있지 않다면, 절차적 설계를 갖는 것이다.  

의존성을 역전시키면 제어 흐름의 주체 역시 역전된다.  
이를 제어 역전 원리, 또는 할리우드 원리라고 한다.  
   
프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다.  
이렇게 완성되지 않은 채로 남겨진 동작을 훅(hook)이라고 부른다.  
훅의 구현 방식은 애플리케이션의 컨텍스트에 따라 달라진다.  

   
# 나아가며
> 어떤 경우에도 이 책에서 배운 캡슐화, 응집도, 결합도의 정의와 원칙은 유효하며 객체지향 패러다임의 중심에는 역할, 책임, 협력이 위치한다.  
   
> 코드를 작성하는 매순간마다 끊임없이 고민하고 트레이드오프하라.