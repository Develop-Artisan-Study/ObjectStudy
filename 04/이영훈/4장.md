# 설계 품질과 트레이드오프

> 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다.

* 결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙은 객체의 상태가 아니라 객체의 행동에 초점을 맞추는 것  
* 객체를 단순한 데이터의 집합으로 바라보는 시각은 객체의 내부 구현을 퍼블릭 인터페이스에 노출시켜 결과적으로 설계가 변경에 취약해짐  

<br>

---
이 장에서는 데이터 중심 설계를 반례로 보면서 객체지향적 설계(책임 주도 설계)의 필요성을 확인한다.

* 데이터 중심 설계의 패턴  
  * 객체의 종류를 저장하는 인스턴스 변수와 인스턴스의 종류에 따라 배타적으로 사용될 인스턴스 변수를 하나의 클래스 안에 함께 포함시킨다
  * 캡슐화 원칙을 지키기 위해 접근자와 수정자를 사용한다
  
<br>

* 캡슐화  
  변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법
* 응집도  
  모듈에 포함된 내부 요소들이 연관돼 있는 정도  
  응집도가 높으면 하나의 객체만 변경시켜도 연관된 객체가 모두 변경된다
* 결합도  
  의존성의 정도, 한 객체가 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도  
  결합도가 높으면 하나의 객체를 변경시키기 위해 다른 객체들까지 변경시켜야 한다  

<br>

* 일반적으로 변경될 확률이 매우 적은 안정적인 모듈과는 결합도가 높아도 상관이 없다. (표준 라이브러리 등)  
  하지만 직접 만든 모듈의 경우 (거의)무조건적으로 결합도가 낮게 설계되어야 한다
  > 직접 작성한 코드는 항상 불안정하며 언제라도 변경될 가능성이 높다. 코드 안에 버그가 존재할 수도 있고 갑자기 요구사항이 변경될 수도 있다. 코드를 완성한 그 순간부터 코드를 수정할 준비를 해야 한다.
* 캡슐화의 정도는 응집도와 결합도에 영향을 미친다.
  
<br>

* 데이터 중심 설계가 가진 대표적인 문제점
  * 캡슐화 위반
  * 높은 결합도
  * 낮은 응집도

<br>

* 문제
  * 접근자와 수정자는 객체 내부에 직접 접근할 수 없게 만들지만,  객체 내부의 상태를 알 수 있도록 작성할 경우 객체는 캡슐화 되지 않는다.  
  이러한 경우 객체 내부의 구현이 변경되면 해당하는 접근자와 수정자에 의존하는 모든 객체를 함께 변경시켜야 한다(결합도가 높아진다).
  * 낮은 응집도는 한 모듈에 변경이 필요할 경우 해당하는 변경을 수용하기 위해 다른 많은 객체를 변경시켜야 한다.

<br>

* 데이터 중심의 설계가 변경에 취약한 이유
  * 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
  * 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.


<br>

---
**캡슐화는 설계의 제1원리다.** 데이터 중심의 설계가 낮은 응집도와 높은 결합도라는 문제로 몸살을 앓게 된 근본적인 원인은 바로 캡슐화의 원칙을 위반했기 때문이다.