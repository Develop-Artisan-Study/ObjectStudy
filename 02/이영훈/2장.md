# 객체지향 프로그래밍
> 어떤 클래스가 필요한지를 고민하기 전에  
> 어떤 객체들이 필요한지 고민하라.
* 도메인(domain)  
  문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
* 캡슐화  
  데이터와 기능을 객체 내부로 함께 묶는 것
* 접근 제어(access control), 접근 수정자(access modifier)  
  객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다.
* 퍼블릭 인터페이스와 구현 
  * 퍼블릭 인터페이스(public interface)   
    객체에서 외부에서 접근이 가능한 부분
  * 구현(implementation)  
    객체에서 외부에서는 접근이 불가능하고 오직 내부에서만 접근이 가능한 부분  
* 구현 은닉(implementation hiding)  
  클래스 작성자가 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨겨놓는 것  
  이를 통해 클래스 작성자가 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 변경할 수 있다.  

<br>
설계가 필요한 이유는 변경을 관리하기 위함이다.
<br><br>

---
* 협력(Collaboration)  
  시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용
* 메시지와 메서드(method)  
  객체가 다른 객체와 상호작용하기 위해 주고받는 것이 **메시지**  
  수신된 메시지를 처리하기 위한 객체 자신만의 방법이 **메서드**
* 의존성  
  어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 메서드를 호출할 수 있을 경우 두 클래스 사이에 의존성이 존재한다고 말한다.
* 컴파일 시간 의존성과 실행 시간 의존성  
  상속을 통한 구현으로 인해 코드의 의존성과 실행 시점의 의존성이 다를 수 있다.  
  이러한 경우 코드가 유연해지고 확장 가능해지지만, 이해하기 어려워질 수 있다.
* 차이에 의한 프로그래밍(programming by difference)  
  부모 클래스와 다른 부분만을 추가해서 새로운 자식 클래스를 쉽고 빠르게 만들어내는 방법
* 업캐스팅(upcasting)  
  자식 클래스가 부모 클래스를 대신하는 것
* 다형성  
  전송하는 메시지는 동일하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라지는 것
* 바인딩  
  * 지연 바인딩(lazy binding), 동적 바인딩(dynamic binding)  
    메시지와 메서드를 **실행시간에** 연결시키는 것
  * 초기 바인딩(early binding), 정적 바인딩(static binding)  
    메시지와 메서드를 **컴파일 시점에** 연결시키는 것
* 추상화  
  추상 클래스를 이용하여 구조를 설계하고 추상 클래스를 상속받은 자식 클래스들을 이용하여 기능을 구현하는 것
* 추상화의 장점
  * 추상화 계층만 놓고 구조를 보면 요구사항을 높은 수준에서 서술할 수 있다.
  * 추상화를 이용하면 설계가 유연해진다.
  > 결론은 간단하다.  
  > 유연성이 필요한 곳에 추상화를 사용하라.
* 합성(composition)  
  다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법 

<br>

--- 
> 비록 아주 사소한 결정이더라도 트레이드오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다.  
> 고민하고 트레이드오프하라.