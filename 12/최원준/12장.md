# 다형성

- 상속을 사용하는 목적은 두가지다.
  - 단순히 코드를 재사용하기 위해서
  - 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서
- 전자라면 상속을 사용해서는 안된다.

## 다형성

- 다형성이라는 단어는 '많은 형태를 가질 수 있는 능력'을 의미한다.
- 다형성은 다음과 같이 분류된다.
  - 유니버설 다형성
    - 매개변수
    - 포함
  - 임시 다형성
    - 오버로딩
    - 강제
- 오버로딩 다형성
  - 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
  - 서로 다른 타입의 파라미터를 받아 동일한 행위를 하는 메서드들이 동일한 이름을 가지는 경우
- 강제 다형성
  - 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식을 가리킨다.
  - 이항 연산자인 '+' 같은 경우는 문자열에 대해서는 문자열들을 연결시키며 정수형에 대해서는 덧셈 연산자로 동작한다.
- 매개변수 다형성
  - 제네릭 프로그래밍과 관련이 높다.
  - 인스턴스 변수나 메서드의 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식
- 포함 다형성
  - 메시지가 동일하더라도 수신 객체의 타입에 따라 실제로 수행되는 행동이 달라진다.
  - 서브타입 다형성이라고 부른다.
  - 전제조건은 자식 클래스가 부모 클래스의 서브타입이어야 한다.
  - 포함 다형성을 위해 상속을 사용하는 가장 큰 이유는 클래스들을 계층으로 쌓아 올린 후 상황에 따라 적절한 메서드를 선택할 수 있는 메커니즘을 제공한다.

## 상속의 양면성

- 객체지향 패러다임의 근간을 이루는 아이디어는 데이터와 행동을 객체라고 불리는 하나의 실행 단위안으로 통일하는 것이다.
- 상속 또한 데이터와 행동을 상속받는다.
  - 데이터 관점의 상속: 부모의 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함할 수 있다.
  - 행동 관점의 상속: 부모의 메서드를 자식 클래스에 포함시킬 수 있다.
- 상속의 목적은 코드 재사용이 아니다.
- 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것이다.
- 상속의 개념
  - 업캐스팅
  - 동적 메서드 탐색
  - 동적 바인딩
  - Self 참조
  - super 참조

### 상속을 이용한 강의평가

- 부모 클래스와 자식 클래스에 동일한 시그니처를 가진 메서드가 존재할 경우 자식 클래스의 메서드 우선순위가 더 높다.
- 상속을 사용하면 새로운 기능을 쉽고 빠르게 추가할 수 있다.
- 새로운 클래스를 자식 클래스로 정의하는 것만으로도 원래 클래스가 가진 데이터와 메서드를 새로운 클래스의 것으로 가질 수 있다.

### 데이터 관점의 상속

- 상속을 인스턴스 관점에서 바라볼때 개념적으로 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스가 존재한다.
- 특별한 방법을 통하지 않는다면 자식 클래스 내부의 부모 클래스에 접근할 수 없다.
- 데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함한다.

### 행동 관점의 상속

- 행동 관점의 상속은 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미한다.
- 부모 클래스의 모든 퍼블릭 메서드는 자식 클래스의 퍼블릭 인터페이스에 포함된다.
- 객체의 경우 서로 다른 상태를 저장할 수 있도록 각 인스턴스별로 독립적인 메모리를 할당받아야 한다.
- 메서드의 경우 동일한 클래스의 인스턴스 끼리 공유하기 때문에 클래스는 한번만 메모리에 로드하고 각 인스턴스 별로 클래스를 가르키는 포인터를 갖게하는 것이 경제적이다.

## 업캐스팅과 동적 바인딩

### 같은 메시지, 다른 메서드

- 선언된 참조 타입과 무관하게 실제로 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 달라질 수 있는 것은 업캐스팅과 동적 바인딩이라는 메커니즘이 작용하기 때문이다.
  - 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다. 이를 **업캐스팅**이라고 부른다.
  - 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다. 컴파일 시점이 아니라 실행 시점에 메서드를 결정하기 때문에 가능하다. 이를 동적 바인딩이라고 부른다.

### 업캐스팅

- 부모 클래스의 인스턴스 대신 자식 클레스의 인스턴스를 사용하더라도 메시지를 처리하는데 문제 없다.
- 컴파일러는 명시적인 타입 변환 없이도 자식 클래스가 부모 클래스를 대체할수 있도록 허용한다
- 대표적인 두 가지가 대입문과 메서드의 파라미터 타입이다.
- 컴파일러 관점에서 자식 클래스는 아무런 제약 없이 부모 클래스를 대체할 수 있기 때문에 부모 클래스와 협력하는 클라이언트는 자식 클래스와도 협력이 가능하다.
- 이러한 설계는 유연하며 확장이 가능하다.

### 동적 바인딩

- 객체지향 언어에서 메서드를 실행하는 방법은 메시지를 전송하는 것이다.
- 컴파일 타임에 호출할 함수를 결정하는 방식
  - 정적 바인딩
  - 초기 바인딩
  - 컴파일타임 바인딩
- 실행될 메서드를 런타임에 결정하는 방식
  - 동적 바인딩
  - 지연 바인딩

## 동적 메서드 탐색과 다형성

- 객체지향 시스템은 다음 규칙에 따라 실행할 메서드를 선택한다
  - 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한다. 존재하면 해당 메서드를 실행하고 종료한다.
  - 메서드를 찾지 못했다면 부모 클래스에서 탐색을 계속한다. 찾을 때 까지 상속 계층을 타고 올라간다.
  - 찾지 못했을 경우 예외를 발생시키며 탐색을 중단한다.
- Self 참조
  - 객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시변수를 자동으로 생성한다.
  - 메시지를 수신한 객체를 가르키도록 설정한다.
  - 동적 메서드 탐색은 self가 가리키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로 이루어 진다.
- 시스템은 class 포인터와 self 참조를 조합해서 메서드를 탐색한다.
- 메서드 탐색은 자식 클래스에서 부모 클래스의 방향으로 진행된다.
  - 자식 클래스가 부모 클래스보다 우선적으로 검색되기 때문에 자식 클래스의 메서드가 우선도를 갖는다.
- 동적 메서드 탐색은 두가지 원리로 구성된다.
  - 자동적인 메시지 위임
    - 자식 클래스는 자신이 이해할 수 없는 메시지를 전송받은 경우 상속 계층을 따라 부모 클래스에게 처리를 위임한다.
  - 동적인 문맥
    - 메시지를 수신했을 때 실제로 어떤 메서드를 실행할지를 결정하는 것은 컴파일 시점이 아닌 실행 시점에서 이루어 진다.
    - 메서드를 탐색하는 경로는 self 참조를 이용해서 결정한다.

### 자동적인 메시지 위임

- 적절한 메서드를 찾을 때 까지 상속 계층을 따라 부모 클래스로 처리가 위임된다.
- 상속을 이용할 경우 프로그래머가 메시지 위임과 관련된 코드를 명시적으로 작성할 필요가 없다.
- 상속 계층을 정의하는 것은 메서드 탐색 경로를 정의한다.
- 일부 언어들은 상속이 아닌 다른 방법들을 이용해 메시지를 자동으로 위임할 수 있는 메커니즘을 제공한다.
  - Ruby의 Module, Scala의 Trait 등
- 동일한 시그니처를 가지는 자식 클래스의 메서드는 부모 클래스의 메서드를 감춘다.
- 하지만 이름만 같고 시그니처가 동일하지 않는다면 사이좋게 공존할 수도 있다.
- 이것이 바로 메시지 오버로딩이다.

#### 메시지 오버라이딩

- 자식 클래스와 부모 클래스 양쪽 모두에 동일한 시그니처를 가진 메서드가 구현되어 있다면 자식 클래스의 메서드가 먼저 검색된다.
- 자식 클래스가 부모 클래스의 메서드를 오버라이딩하면 자식 클래스에서 부모 클래스로 향하는 메서드 탐색 순서 때문에 자식 클래스의 메서드가 부모 클래스의 메서드를 감추게 된다.

#### 메서드 오버로딩

- 메서드 명은 동일하지만 시그니처가 다르면 동일한 이름의 메서드가 공존할 수 있다.
- 메서드 오버라이딩은 메서드를 감추지만 메서드 오버로딩은 사이좋게 공존한다.

### 동적인 문맥

- 메시지 전송 코드만으로는 어떤 클래스의 어떤 메서드가 실행될지를 알 수 없다.
- 메시지를 수신한 객체가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 동적으로 바뀐다.
- 이를 결정하는 것은 수신한 객체를 가르키는 self 참조이다.
- Self 참조가 동적 문맥을 결정한다는 사실은 종종 어떤 메서드가 실행될지를 예상하기 어렵게 만든다.
- 대표적으로 자신에게 다시 메시지를 전송하는 self 전송이다.
  - Self 전송은 자식 클래스에서 부모 클래스 방향으로 진행되는 동적 메서드 탐색 경오를 다시 self 참조가 가리키는 원래의 자식 클래스로 이동시킨다.
  - Self 전송이 깊은 상속 계층과 계층 중간중간에 함정처럼 숨겨져 있는 메서드 오버라이딩과 만나면 극단적으로 이해하기 어려운 코드가 만들어진다.

### 이해할 수 없는 메시지

#### 정적 타입 언어와 이해할 수 없는 메시지

- 정적 타입 언어는 코드를 컴파일 할때 상속 계층 안의 클래스들이 메시지를 이해할 수 있는지 여부를 판단한다.
- 상속 계층을 따라가면서 메시지를 처리할 수 있는 메서드가 존재하는지 검색하며 없다면 컴파일 에러를 발생시킨다.

#### 동적 타입 언어와 이해할 수 없는 메시지

- 동적 타입 언어는 컴파일 단계가 존재하지 않아 실제로 코드를 실행해보기 전까지 메시지 처리 가능 여부를 판단할 수 없다.
- 최상위 클래스까지 메서드를 탐색한 후 처리할 수 없다는 사실을 발견하면 현재 객체에게 메시지를 이해할 수 없다는 메시지를 전송한다.
- 하지만 동적 타입 언어는 이해할 수 없는 메시지에 대해 예외를 던지는 것 외에도 정의되지 않은 메시지를 별도로 처리할 수 있다.
- 이러한 능력을 통해 메시지가 선언된 인터페이스와 메서드가 정의된 구현을 분리할 수 있다.
- 이런 특성과 유연성은 코드를 수정하기 어렵게 만들고 디버깅을 복잡하게 만들기도 한다.

### self 대 super

- Self 참조의 가장 큰 특징은 동적이라는 점이다.
- 이와 대비해서 언급할만한 것은 super 참조이다.
- 자식 클래스에서 부모 클래스의 구현을 재사용해야하는 경우가 있다.
- 이를 위해 부모 클래스의 변수나 메서드에 접근할 수 있도록 super 참조라는 내부 변수를 제공한다.
- Super 참조는 self참조와 다르게 부모 클래스로부터 메서드 탐색을 시작하도록 한다.
- Super 참조를 통해 메시지를 전송하는 것은 부모 클래스의 인스턴스에 메시지를 전송하는것 처럼 보이기에 super 전송이라고 부른다.
- 동적 바인딩, self 참조, super 참조는 상속을 이용해 다형성을 구현하고 코드를 재사용하기 위한 핵심적인 재료이다.

## 상속 대 위임

### 위임과 self 참조

- 상속 관계로 연결된 클래스 사이에서는 자동적인 메시지 위임이 일어난다.
- 상속은 동적으로 메시지를 탐색하기 위해 현재의 실행 문맥을 가지고 있는 self 참조를 전달한다.
- 이 객체들 사이에서 메시지를 전달하는 과정은 자동으로 이루어진다.
- 이를 자동적인 메시지 위임이라고 부른다.

### 프로토 타입 기반의 객체지향 언어

- 프로토타입 기반의 객체지향 언어에서 상속을 구현하는 유일한 방법은 객체 사이의 위임을 이용하는 것이다.

- 클래스 기반의 객체지향 언어들과 동일하지만 다른 부분이 상속을 이용해 참조를 전달하는 것이 아닌 위임을 이용해 참조를 전달한다.

  