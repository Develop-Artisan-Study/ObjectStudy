# 다형성
> 상속의 목적은 코드 재사용이 아니다.  
> 상속은 타입 계층을 구조화하기 위해 사용해야 한다.  

## 다형성
- 다형성  
  하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력  
  여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법
  - 유니버설(Universal) 다형성
    - 매개변수(Parametric) 다형성  
      변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식  
      제네릭 프로그래밍과 관련이 높다
    - 포함(Inclusion) 다형성  
      메시지가 동일하더라도 수신한 객체 타입에 따라 실제로 수행되는 행동이 달라지는 능력  
      서브타입 다형성이라고도 부른다  
      객체지향 프로그래밍에서 가장 널린 형태의 다형성이며, 특별한 언급 없이 다형성이라고 할 때는 포함 다형성을 의미하는 것이 일반적
  - 임시(Ad Hoc) 다형성
    - 오버로딩(Overloading) 다형성  
      하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우
    - 강제(Coercion) 다형성  
      언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식
   
상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축하는 것이다.

## 상속의 양면성
상속을 이해하기 위해 필요한 개념들
- 업캐스팅
- 동적 메서드 탐색
- 동적 바인딩
- self 참조
- super 참조
   
메서드 오버라이딩  
자식 클래스 안에서 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것   
   
메서드 오버로딩  
부모 클래스에서 재정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가하는 것  
   
본 장에서는 상속과 관련된 개념을 설명하기 위해 코드 재사용을 활용한 것일 뿐, **실제 코드를 작성할 때는 코드 재사용을 목적으로 상속을 사용해서는 안 된다**

### 데이터 관점의 상속
데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스 변수를 포함하는 것

### 행동 관점의 상속
부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것  
부모 클래스의 어떤 메서드가 자식 클래스에 포함될지는 차이가 있을 수 있으나 공통적으로 부모 클래스의 퍼블릭 메서드는 모두 자식 클래스의 퍼블릭 인터페이스에 포함된다  
   
동일한 클래스의 메서드는 클래스 인스턴스들끼리 공유할 수 있도록 한 번만 메모리에 로드되고 각 인스턴스가 포인터를 갖고 접근한다.

## 업캐스팅과 동적 바인딩
### 같은 메시지, 다른 메서드
- 업캐스팅  
  부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능
- 동적 바인딩  
  선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정되는 것

### 업캐스팅
부모 클래스의 인스턴스에게 전송할 수 있는 메시지를 자식 클래스의 인스턴스에게 전송할 수 있다.  
모든 객체지향 언어는 이 과정에서 명시적인 타입 변환 없이 가능하다.  
부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해서는 명시적인 타입 캐스팅이 필요하며, 이를 다운캐스팅이라 부른다.  

### 동적 바인딩
- 정적 바인딩, 초기 바인딩, 컴파일타임 바인딩  
  코드 상에서 함수를 호출하는 구문이 나타났을 때, 실제로 실행되는 코드가 바로 그 함수인 경우
- 동적 바인딩, 지연 바인딩  
  객체의 메서드를 실행하기 위해서는 해당 객체가 어떤 클래스에 포함되는지, 상속계층의 어디에 위치하는지를 알아야 한다.  
  이러한 과정이 런타임에 이루어져 실제로 실행되는 메서드가 런타임에 결정되는 방식을 동적 바인딩이라 한다.  
   
객체지향 언어가 제공하는 업캐스팅과 동적 바인딩을 이용하면 부모 클래스 참조에 대한 메시지 전송을 자식 클래스에 대한 메서드 호출로 변환할 수 있다.

## 동적 메서드 탐색과 다형성
객체지향 시스템이 실행할 메서드를 선택하는 규칙
1. 메시지를 수신한 객체가 적합한 메서드를 가지고 있다면 이를 실행하고 종료한다.
2. 메서드를 찾지 못했다면 부모 클래스에서 메서드를 탐색한다. 찾지 못한다면 이를 반복한다.
3. 상속 계층의 최상위 클래스에 도달할 때 까지 실행할 메서드를 찾지 못한다면 예외를 발생시키고 종료한다.
   
self 참조는 메시지를 수신한 객체를 가리키는 임시 변수이다.  
시스템은 class 포인터와 parent 포인터, self 참조를 이용해 메서드 탐색을 진행한다.  
정적 타입 언어에서는 this라는 키워드를 사용하기도 한다.
   
메서드 탐색은 자식 클래스에서 부모 클래스 방향으로 진행되기 때문에 항상 자식 클래스의 메서드가 부모 클래스의 메서드보다 더 높은 우선순위를 가지게 된다.  
   
### 자동적인 메시지 위임
객체가 메시지를 수신하면 적절한 메서드를 찾을 때까지 상속 계층을 따라 부모 클래스로 처리가 위임된다.  
상속을 이용할 경우 이 과정이 메시지 위임과 관련된 코드를 프로그래머가 명시적으로 작성할 필요 없이 자동적으로 수행된다.
   
메서드 오버라이딩은 자식 클래스의 메서드가 동일한 시그니처를 가진 부모 클래스의 메서드보다 먼저 탐색되기 때문에 벌어지는 현상이다.  
   
이름만 같고 시그니처가 다른 메서드는 상속 계층에 걸쳐 공존할 수도 있다. 이것이 메서드 오버로딩이다.  
   
C++ 에서는 상속 계층 사이에서의 오버로딩을 허용하지 않는다. 이를 이름 숨기기(name hiding)이라고 한다.  
이와 같이 동적 메서드 탐색과 관련된 규칙은 언어마다 다를 수 있다.

### 동적인 문맥
self 참조가 가리키는 객체가 무엇인지에 따라 메서드 탐색을 위한 상속 계층의 범위가 동적으로 변할 수 있다.  
따라서 self 참조가 가리키는 객체의 타입을 변경함으로써 객체가 실행될 문맥을 동적으로 바꿀 수 있다.  
   
상속 계층 안에서 self 전송을 사용하면 메서드를 찾기 위해 self 참조에서부터 다시 메서드를 탐색하기 때문에 자식 클래스에서 overriding된 메서드가 실행될 수 있다.  
이와 같이 동적인 문맥은 이해하기 어려운 코드를 만들 수 있다.

### 이해할 수 없는 메시지
최상위 클래스까지 탐색 후 처리할 수 없는 메시지를 처리하는 방법은 프로그래밍 언어가 정적 타입 언어에 속하는지, 동적 타입 언어에 속하는지에 따라 달라진다.  
- 정적 타입 언어  
  컴파일 에러를 발생시킨다
- 동적 타입 언어  
  런타임에서 '메서드를 찾지 못함 메시지'를 전송한다  
  이에 응답하는 메서드를 구현하면 인터페이스에 정의되지 않은 메시지를 처리하는 것이 가능하다

### self 대 super
self 전송은 메시지를 수신하는 객체의 클래스에 따라 메서드를 탐색할 시작 위치를 동적으로 결정한다  
super 전송은 항상 메시지를 전송하는 클래스의 부모 클래스에서부터 상속 계층 탐색을 시작한다

## 상속 대 위임
- 위임(delegation)  
  자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것, self 참조를 전달함
- 포워딩  
  처리를 요청할 때 self 참조를 전달하지 않는 것  
  코드 재사용을 위해 사용
   
위임의 정확한 용도는 클래스를 이용한 상속 관계를 객체 사이의 합성 관계로 대체해서 다형성을 구현하는 것이다.  
   
상속은 이러한 구현을 자동으로 처리해 준다.

### 프로토타입 기반의 객체지향 언어
프로토타입 기반 객체지향 언어는 (클래스가 아닌)객체 사이의 메시지 위임을 자동으로 처리해준다.  
클래스가 존재하지 않고 객체만 존재하는 프로토타입 언어에서 상속을 구현하는 유일한 방법은 객체 사이의 위임을 이용하는 것이다.  
   
자바스크립트의 프로토타입 체인을 통해 자동적인 메시지 위임을 구현하면 클래스 없이 다형성을 구현할 수 있다.  
객체지향 패러다임에서 클래스가 필수 요소는 아니다.  
상속 이외의 방법으로도 다형성을 구현할 수 있다.
